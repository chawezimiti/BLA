use_data(soil)
setwd("C:/Users/stxcm28/OneDrive - The University of Nottingham/Desktop/BLA")
use_data(soil)
soil<-read.csv("soilxx.csv")
library(devtools)
head(soil)
use_data(soil)
use_r("soil")
devtools::load_all(".")
library(MASS)
library(bestNormalize)
library(aplpack)
dat<-data.frame(x=log(soil$P), y=soil$yield) #Input for bagplot is a dataframe of x and y.
bag<-bagplot(dat, na.rm = FALSE, approx.limit = 300,
show.outlier = TRUE, show.whiskers = F,
show.looppoints = TRUE, show.bagpoints = TRUE,
show.loophull = TRUE, show.baghull = TRUE,
create.plot = TRUE, add = FALSE, pch = 16, cex = 0.4,
dkmethod = 2, precision = 1, verbose = FALSE)
vals<-rbind(bag$pxy.bag,bag$pxy.outer) # new data set without bivariate outliers
pH_bc <- box_cox_transform(soil$pH, lambda)
yj <- yeojohnson(soil$pH)
pH_yj <- yj$x.t
summastat(pH_yj) # can be assumed to be from normal distribution
dat2<-data.frame(pH_yj,soil$yield)
bag<-bagplot(dat2, na.rm = FALSE, approx.limit = 300,
show.outlier = TRUE, show.whiskers = F,
show.looppoints = TRUE, show.bagpoints = TRUE,
show.loophull = TRUE, factor = 2.7, show.baghull = TRUE,
create.plot = TRUE, add = FALSE, pch = 16, cex = 0.4,
dkmethod = 2, precision = 1, verbose = FALSE)
bag<-bagplot(dat2, na.rm = FALSE, approx.limit = 300,
show.outlier = TRUE, show.whiskers = F,
show.looppoints = TRUE, show.bagpoints = TRUE,
show.loophull = TRUE, factor = 3, show.baghull = TRUE,
create.plot = TRUE, add = FALSE, pch = 16, cex = 0.4,
dkmethod = 2, precision = 1, verbose = FALSE)
vals2<-rbind(bag$pxy.bag,bag$pxy.outer) # new excludes bivariate outliers
cbvn(vals2, start = start, sigh=0.5, model = "lp",
xlab=expression("pH/tranformed YeoJohnson"),
ylab=expression("Yield/ t ha"^-1),
pch=16, col="grey")
start<-c(20,4.6,13.3, 0.003, 9.27, 0.99,1.76, 0.118)
cbvn(vals2, start = start, sigh=0.5, model = "lp",
xlab=expression("pH/tranformed YeoJohnson"),
ylab=expression("Yield/ t ha"^-1),
pch=16, col="grey")
#'
#' Miti. c., Milne. A. E., Giller. K. E. and Lark. R. M (2024). Exploration of data
#' for analysis using boundary line methodology. Computers and Electronics in Agriculture
#' 219 (2024) 108794.
#'
#' @examples
#' x<-evapotranspiration$`ET(mm)`
#' y<-evapotranspiration$`yield(t/ha)`
#' expl_boundary(x,y,10,100) # recommendation is to set simulations to greater than 1000
#'
expl_boundary<-function(x,y,shells=10,simulations=1000,method="sd-enclidean",plot=TRUE,...){
if(simulations>=1000) message("Note: This function might take longer to execute when running a large number of simulations.\n")
## Selection of the x_min and x_max index values----------------------------------------
upper.peel<-function(peel){
min.x.index<-which(peel[,2]==max(peel[,2][which(peel[,1]==min(peel[,1]))]) & peel[,1]==min(peel[,1])) # selection of min
max.x.index<-which(peel[,2]==max(peel[,2][which(peel[,1]==max(peel[,1]))]) & peel[,1]==max(peel[,1])) # and max.x.index
if(min.x.index<max.x.index){                                                                          # even when two values
op<-peel[min.x.index:max.x.index,]                                                                  # occur. The highest is used
}else{
op<-rbind(peel[(min.x.index:nrow(peel)),],
peel[(1:max.x.index),]
)
}
return(op)
}
## Removing NA'S from the data ---------------------------------------------------------
data<- data.frame(x=x,y=y)
test<-which(is.na(data$x)==TRUE|is.na(data$y)==TRUE)
if(length(test)>0){
data1<-data[-which(is.na(data$x)==TRUE|is.na(data$y)==TRUE),]}else{
data1<-data
}
x<-data1$x
y<-data1$y
dat<-cbind(x,y)
## setting the output area -------------------------------------------------------------
if(plot==TRUE){
old_par <- par(no.readonly = TRUE) # Save the current graphical parameters
on.exit(par(old_par))# Ensure the original graphical parameters are restored on exit
plot_layout<-rbind(c(1,1,2),c(1,1,3))
layout(plot_layout)
plot(dat,...)}
## Determination of the convex hull-----------------------------------------------------
peels<-list()
left<-list()
right<-list()
n<-length(dat[,1]) #: sample size
Sigma<-cov(dat)
for(i in 1:shells){
ch.index<-chull(dat) # find convex hull (index values for points)
p1<-dat[ch.index,]   # extract peel 1
p1_2<-p1[!duplicated(p1), ]
p1.upper<-upper.peel(p1_2)
p1.upperx<-data.frame(x=p1.upper[,1],y=p1.upper[,2])
ifelse( p1.upperx[1,2]!=max(p1.upperx$y),
peels[[i]]<-split(p1.upperx,ifelse(p1.upperx$x<p1.upperx$x[which(p1.upperx$y==max(p1.upperx$y))],0,1)),
peels[[i]]<-split(p1.upperx,ifelse(p1.upperx$x<= p1.upperx$x[which(p1.upperx$y==max(p1.upperx$y))],0,1)))
index.func<-function(x,y){
del<-list()
for(i in 1:length(y[,1])){
del[[i]]<-which(x[,1]==y[,1][i]& x[,2]==y[,2][i])
}
del
d<-unlist(del, recursive = TRUE, use.names = TRUE)
d
}
dat<-dat[-index.func(dat,p1.upper),]
}
for(i in 1:shells){
left[[i]]<-peels[[i]][[1]]
right[[i]]<-peels[[i]][[2]]
df1 <- do.call("rbind", left)
df2 <- do.call("rbind", right)
}
if(plot==TRUE){
points(df1$x,df1$y,col="red", pch=16)
points(df2$x,df2$y,col="blue", pch=16)}
pointL<-df1
pointR<-df2
## Clustering matrics-------------------------------------------------------------------
#### 1. Calculating the euclidean distance of vertices to center------------------------
ED1_sd<-sd(sqrt((mean(x)-df1[,1])^2+(mean(y)-df1[,2])^2))
ED2_sd<-sd(sqrt((mean(x)-df2[,1])^2+(mean(y)-df2[,2])^2))
#### 2. Calculating the perimeter and of the boundary points----------------------------
perimL <- AP(df1)$Perimeter # left section
perimR <- AP(df2)$Perimeter# right section
areaL <- AP(df1)$Area # left section
areaR <- AP(df2)$Area# right section
polygonL <- AP(df1)$Polygon # left section
polygonR <- AP(df2)$Polygon # right section
### Monte Carlo simulation for evidence testing  ---------------------------------------
ED1_sim<-list()
ED2_sim<-list()
ED_all_sd_rise<-vector()
ED_all_sd_fall<-vector()
perimL_sim<-vector()
perimR_sim<-vector()
areaL_sim<-vector()
areaR_sim<-vector()
for(j in 1:simulations){
peels<-list()
left<-list()
right<-list()
## simulation of data using summary statistics of the available data------------------
dat<-mvrnorm(n,mu=c(mean(x),mean(y)),Sigma)
## Removal of outliers from the simulated data----------------------------------------
cov.robust <- cov.rob(dat)
md <- mahalanobis(dat, cov.robust$center, cov.robust$cov)
threshold <- qchisq(0.995, df=ncol(dat))  # 1% significance level
outliers <- md > threshold
dat <- dat[!outliers, ]
## Determination of convex hull for the simulated data--------------------------------
for(i in 1:shells){
ch.index<-chull(dat) # find convex hull (index values for points)
p1<-dat[ch.index,]   # extract peel 1
p1_2<-p1[!duplicated(p1), ] # removes duplicate values i.e if two rows have same x and y values
p1.upper<-upper.peel(p1_2)
p1.upperx<-data.frame(x=p1.upper[,1],y=p1.upper[,2])
ifelse( p1.upperx[1,2]!=max(p1.upperx$y),
peels[[i]]<-split(p1.upperx,ifelse(p1.upperx$x<p1.upperx$x[which(p1.upperx$y==max(p1.upperx$y))],0,1)),
peels[[i]]<-split(p1.upperx,ifelse(p1.upperx$x<= p1.upperx$x[which(p1.upperx$y==max(p1.upperx$y))],0,1)))
index.func<-function(x,y){
del<-list()
for(i in 1:length(y[,1])){
del[[i]]<-which(x[,1]==y[,1][i]& x[,2]==y[,2][i])
}
del
d<-unlist(del, recursive = TRUE, use.names = TRUE) # convert all the indexed rows into one vector
d
}
dat<-dat[-index.func(dat,p1.upper),]
}
for(i in 1:shells){
left[[i]]<-peels[[i]][[1]]
right[[i]]<-peels[[i]][[2]]
}
df1 <- do.call("rbind", left)
df2 <- do.call("rbind", right)
# 1. Enclidean distance measure-------------------------------------------------------
ED1_2<-sqrt((mean(x)-df1[,1])^2+(mean(y)-df1[,2])^2)
ED2_2<-sqrt((mean(x)-df2[,1])^2+(mean(y)-df2[,2])^2)
ED1_sim[[j]]<-ED1_2
ED2_sim[[j]]<-ED2_2
# 2. Perimeter measure---------------------------------------------------------------
perimL_2 <- AP(df1)$Perimeter # left section
perimR_2 <- AP(df2)$Perimeter# right section
areaL_2 <- AP(df1)$Area # left section
areaR_2 <- AP(df2)$Area# right section
perimL_sim[j]<-perimL_2
perimR_sim[j]<-perimR_2
areaL_sim[j]<-areaL_2
areaR_sim[j]<-areaR_2
}
#---------------------------------------------------------------------------------------
for(i in 1:simulations){
ED_all_sd_rise[i]<-sd(ED1_sim[[i]])
}
for(i in 1:simulations){
ED_all_sd_fall[i]<-sd(ED2_sim[[i]])
}
## Calculating test indices-------------------------------------------------------------
### 1. sd test indices------------------------------------------------------------------
p_sd_rise<-length(which(ED_all_sd_rise<=ED1_sd))/length(ED_all_sd_rise)
p_sd_fall<-length(which(ED_all_sd_fall<=ED2_sd))/length(ED_all_sd_fall)
MeanSDr<-mean(ED_all_sd_rise)
MeanSDf<-mean(ED_all_sd_fall)
### 2. Perimeter area test indices-----------------------------------------------------------
p_perim_rise<-length(which(perimL_sim<=perimL))/length(perimL_sim)
p_perim_fall<-length(which(perimR_sim<=perimR))/length(perimR_sim)
p_area_rise<-length(which(areaL_sim<=areaL))/length(areaL_sim)
p_area_fall<-length(which(areaR_sim<=areaR))/length(areaR_sim)
MeanperimL<-mean(perimL_sim)
MeanperimR<-mean(perimR_sim)
MeanareaL<-mean(areaL_sim)
MeanareaR<-mean(areaR_sim)
## Output preparation-------------------------------------------------------------------
if(method=="sd-enclidean"){
Index<-c("sd","sd")
Section<-c("Left","Right")
value<-c(ED1_sd,ED2_sd)
Mean<-c(MeanSDr,MeanSDf)
p_value<-c(p_sd_rise, p_sd_fall)
## Plotting the data points for visualization-------------------------------------------
if(plot==TRUE){
hist(ED_all_sd_rise,freq = FALSE, xlab="sd",main = "Left")
lines(density(ED_all_sd_rise), lwd = 1, col = "red")
abline(v=ED1_sd, col="red",lty=2)
hist(ED_all_sd_fall,freq = FALSE,xlab="sd",main = "Right")
lines(density(ED_all_sd_fall), lwd = 1, col = "red")
abline(v=ED2_sd, col="red",lty=2)
}
}
if(method=="Perimeter"){
Index<-c("Perimeter","Perimeter")
Section<-c("Left","Right")
value<-c(perimL,perimR)
Mean<-c(MeanperimL,MeanperimR)
p_value<-c(p_perim_rise, p_perim_fall)
## Plotting the data points for visualization-------------------------------------------
if(plot==TRUE){
hist(perimL_sim,freq = FALSE, xlab="Perimeter",main = "Left")
lines(density(perimL_sim), lwd = 1, col = "red")
abline(v=perimL, col="red",lty=2)
hist(perimR_sim,freq = FALSE,xlab="Perimeter",main = "Right")
lines(density(perimR_sim), lwd = 1, col = "red")
abline(v=perimR, col="red",lty=2)
}
}
if(method=="Area"){
Index<-c("Area","Area")
Section<-c("Left","Right")
value<-c(areaL,areaR)
Mean<-c(MeanareaL,MeanareaR)
p_value<-c(p_area_rise, p_area_fall)
## Plotting the data points for visualization-----------------------------------------
if(plot==TRUE){
hist(areaL_sim,freq = FALSE, xlab="Perimeter",main = "Left")
lines(density(areaL_sim), lwd = 1, col = "red")
abline(v=areaL, col="red",lty=2)
hist(areaR_sim,freq = FALSE,xlab="Perimeter",main = "Right")
lines(density(areaR_sim), lwd = 1, col = "red")
abline(v=areaR, col="red",lty=2)
}
}
result<-data.frame(Index,Section,value,Mean,p_value)
return(result)
}
yj <- yeojohnson(soil$pH)
pH_yj <- yj$x.t
summastat(pH_yj) # can be assumed to be from normal distribution
dat2<-data.frame(pH_yj,soil$yield)
bag<-bagplot(dat2, na.rm = FALSE, approx.limit = 300,
show.outlier = TRUE, show.whiskers = F,
show.looppoints = TRUE, show.bagpoints = TRUE,
show.loophull = TRUE, factor = 3, show.baghull = TRUE,
create.plot = TRUE, add = FALSE, pch = 16, cex = 0.4,
dkmethod = 2, precision = 1, verbose = FALSE)
vals2<-rbind(bag$pxy.bag,bag$pxy.outer) # new excludes bivariate outliers
x<-vals2[,1]
y<-vals2[,2]
devtools::load_all(".")
x<-vals2[,1]
y<-vals2[,2]
x<-vals2[,1]
y<-vals2[,2]
expl_boundary(x,y,10,1000, method = "Perimeter") # there is evidence of bounding structures
devtools::load_all(".")
expl_boundary(x,y,10,1000, method = "Perimeter") # there is evidence of bounding structures
expl_boundary(x,y,10,1000, method = "Perimeter") # there is evidence of bounding structures
devtools::load_all(".")
yj <- yeojohnson(soil$pH)
library(MASS)
library(bestNormalize)
library(aplpack)
yj <- yeojohnson(soil$pH)
pH_yj <- yj$x.t
summastat(pH_yj) # can be assumed to be from normal distribution
dat2<-data.frame(pH_yj,soil$yield)
bag<-bagplot(dat2, na.rm = FALSE, approx.limit = 300,
show.outlier = TRUE, show.whiskers = F,
show.looppoints = TRUE, show.bagpoints = TRUE,
show.loophull = TRUE, factor = 2.7, show.baghull = TRUE,
create.plot = TRUE, add = FALSE, pch = 16, cex = 0.4,
dkmethod = 2, precision = 1, verbose = FALSE)
vals2<-rbind(bag$pxy.bag,bag$pxy.outer) # new excludes bivariate outliers
x<-vals2[,1]
y<-vals2[,2]
length(x)
bag<-bagplot(dat2, na.rm = FALSE, approx.limit = 300,
show.outlier = TRUE, show.whiskers = F,
show.looppoints = TRUE, show.bagpoints = TRUE,
show.loophull = TRUE, factor = 2.7, show.baghull = TRUE,
create.plot = TRUE, add = FALSE, pch = 16, cex = 0.4,
dkmethod = 2, precision = 1, verbose = FALSE)
bag<-bagplot(dat2, na.rm = FALSE, approx.limit = 300,
show.outlier = TRUE, show.whiskers = F,
show.looppoints = TRUE, show.bagpoints = TRUE,
show.loophull = TRUE, factor = 3, show.baghull = TRUE,
create.plot = TRUE, add = FALSE, pch = 16, cex = 0.4,
dkmethod = 2, precision = 1, verbose = FALSE)
length(soil$pH)
vals2<-rbind(bag$pxy.bag,bag$pxy.outer) # new excludes bivariate outliers
x<-vals2[,1]
y<-vals2[,2]
expl_boundary(x,y,10,1000, method = "Perimeter") # there is evidence of bounding structures
plot(vals2[,1],vals2[,2]) # a linear model is appropriate
expl_boundary(x,y,10,1000, method = "Area")
devtools::check_win_devel()
soil<-read.csv("soilxx.csv")
head(soil)
use_data(soil)
library(devtools)
use_data(soil)
use_r("soil")
devtools::load_all(".")
library(MASS)
library(bestNormalize)
library(aplpack)
summastat(soil$P) # From results, P can not be assumed to be from a normal distribution
summastat(soil$P) # From results, P can not be assumed to be from a normal distribution
summastat(log(soil$P)) # The log-transformed P can be assumed to be from a normal distribution
dat<-data.frame(x=log(soil$P), y=soil$yield) #Input for bagplot is a dataframe of x and y.
bag<-bagplot(dat,show.whiskers = F)
vals<-rbind(bag$pxy.bag,bag$pxy.outer) # new data set without bivariate outliers
x<-vals[,1]
y<-vals[,2]
expl_boundary(x,y,10,10, method = "Perimeter") # there is evidence of bounding structures
plot(x,y) # a trapezium boundary model is appropriate
start<-c(3.5,3.7,13.35,47.7,-8.4,mean(x),mean(y),sd(x),sd(y),cor(x,y))
sigh<-c(0.3,0.4,0.5,0.7,0.8,0.9,1,1.1)
ble_profile(data=vals, start=start, sigh=sigh, model = "trapezium")
cbvn(data=vals, start = start, sigh=0.4, model = "trapezium",
optim.method =  "BFGS",
xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Yield/ t ha"^-1),
pch=16, col="grey")
start<-list(
c(4.3,3.4,13.8,32.8,-4.9,mean(x),mean(y),sd(x),sd(y),cor(x,y)),
c(2.5,4.1,13.42,32,-4.8,mean(x),mean(y),sd(x),sd(y),cor(x,y)),
c(3.5,3.7,13.35,47.7,-8.4,mean(x),mean(y),sd(x),sd(y),cor(x,y)),
c(2.83,4.11,13.7,32.,-4.6,mean(x),mean(y),sd(x),sd(y),cor(x,y)),
c(4.3,3.4,13.59,28,-3.6,mean(x),mean(y),sd(x),sd(y),cor(x,y))
)
models <- lapply(start, function(start) {
m <- tryCatch(cbvn(data=vals, start = start, sigh=0.4, model = "trapezium",
optim.method =  "BFGS",
xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Yield/ t ha"^-1),
pch=16, col="grey"),
error=function(e) NA)
return(m)
})
model_1 <- models[[which.min(unlist(lapply(X=models,FUN = function(a){
b<-tryCatch(a$AIC[2,1],error=function(e) NA)
return(b)})))]]
model_1
P_data <-log(soil$P) # extracting soil P from the data
P_data[which(is.na(P_data)==T)]<-mean(P_data,na.rm=T) # replacing missing values with the mean value
P<-predictBL(model_1,P_data) # boundary yield for soil P
points(P_data, P, col="red", pch=16)
summastat(soil$pH) # can not be assumed to be from normal distribution
summastat(log(soil$pH)) # can not be assumed to be from normal distribution
model_bc <- lm(soil$pH ~ 1)
# Simplified approach: Use boxcox function directly on the numeric vector
bcox<- MASS::boxcox(model_bc, plotit = TRUE)
maxlik<-max(bcox$y)
lambda<-bcox$x[which(bcox$y==maxlik)]
print(lambda)
## Define the Box-Cox transformation function
box_cox_transform <- function(data, lambda) {
if (lambda == 0) {
log(data)
} else {
(data^lambda - 1) / lambda
}
}
pH_bc <- box_cox_transform(soil$pH, lambda)
summastat(pH_bc) # can not be assumed to be from normal distribution
yj <- yeojohnson(soil$pH)
pH_yj <- yj$x.t
summastat(pH_yj) # can be assumed to be from normal distribution
dat2<-data.frame(pH_yj,soil$yield)
bag<-bagplot(dat2, show.whiskers = F)
vals2<-rbind(bag$pxy.bag,bag$pxy.outer) # new excludes bivariate outliers
x<-vals2[,1]
y<-vals2[,2]
expl_boundary(x,y,10,10, method = "Perimeter") # there is evidence of bounding structures
plot(vals2[,1],vals2[,2], pch=16, col="grey") # a linear model is appropriate
start<-list(
c(20,4.3,13.57,mean(x),mean(y),sd(x),sd(y),cor(x,y)),
c(21.3,5.4,13.44,mean(x),mean(y),sd(x),sd(y),cor(x,y)),
c(20.9,5.2,13.57,mean(x),mean(y),sd(x),sd(y),cor(x,y)),
c(18.47,3.54,13.87,mean(x),mean(y),sd(x),sd(y),cor(x,y)),
c(20.7,4.5,13.67,mean(x),mean(y),sd(x),sd(y),cor(x,y))
)
models2 <- lapply(start, function(start) {
m <- tryCatch(cbvn(vals2, start = start, sigh=0.4, model = "lp",
xlab=expression("pH/tranformed YeoJohnson"),
ylab=expression("Yield/ t ha"^-1),
pch=16, col="grey"),
error=function(e) NA)
return(m)
})
model_2 <- models2[[which.min(unlist(lapply(X=models2,FUN = function(a){
b<-tryCatch(a$AIC[2,1],error=function(e) NA)
return(b)})))]]
model_2
pH_data<- yeojohnson(soil$pH)$x.t # extracting soil pH from data and transforming it
pH_data[which(is.na(pH_data)==T)]<-mean(pH_data,na.rm=T)#replacing missing values with mean
pH<-predictBL(model_2,pH_data) # predicting boundary yield
points(pH_data, pH, col="red", pch=16)
plot(vals[,1],vals[,2], xlab=expression("Phosphorus/ln(mg kg"^-1*")"),
ylab="yield/ t ha", pch=16, col="16")
xa<-seq(min(vals[,1]),max(vals[,1]),length.out =1000) #values of soil P to predict yield
ya<-numeric() # empty vector to contain predicted boundary yield values
for(i in 1: length(xa)){ # predicting boundary yield values
ya[i]<-min(model_1$Parameters[1,1]+model_1$Parameters[2,1]*xa[i]
,model_1$Parameters[3,1],
model_1$Parameters[4,1]+model_1$Parameters[5,1]*xa[i])
}
lines(xa,ya, col="red", lwd=1.5) # adding the boundary values for each soil P value
crit_P<-(model_1$Parameters[3,1]-model_1$Parameters[1,1])/model_1$Parameters[2,1]
abline(v=crit_P, col="red", lty=5) # adding critical soil P to plot
params <- mvrnorm(n = 100000,mu = model_1$Parameters[1:3,1], Sigma = solve(model_1$Hessian[1:3,1:3]))
crit_points<-(params[,3]-params[,1])/params[,2]
CI_95 <- quantile(crit_points, c(0.025,0.975))
abline(v=CI_95, col="blue", lty=1, lwd=1.5)
P_limProb<-pnorm(P_data, mean = mean(crit_points), sd = sd(crit_points))
head(P_limProb)
plot(exp(vals[,1]),vals[,2], xlab=expression(bold("Phosphorus/ mg kg"^-1)),
ylab=expression(bold("Yield/ t ha"^-1)), col="grey", pch=16, xlim=c(0,120),
font.axis = 2)
lines(exp(xa),ya, col="red", lwd=1.5)
abline(v=exp(crit_P), col="red")
CI_95 <- exp(quantile(crit_points, c(0.025,0.975)))
polygon(c(CI_95[1],CI_95[2],CI_95[2],CI_95[1],CI_95[1]), c(0,0,18,18,0),
col=adjustcolor( "red", alpha.f = 0.2),border=NA)
legend("bottomright", legend = c("Boundary line", "95% CI"),
lty = c(1,NA), pch = c(NA,15), lwd = c(1.5, NA),
col = c("red",col=adjustcolor( "red", alpha.f = 0.2) ))
plot(vals2[,1],vals2[,2], xlab="pH", ylab=expression("Yield/ t ha"^-1),
col="grey", pch=16) # ploting soil pH vs yield
xc<-seq(min(vals2[,1]), max(vals2[,1]),length.out =1000)# values of soil pH to be predicted
yc<-numeric() # vector for predicted boundary yield values
for(i in 1: length(xc)){ # predicting boundary yield values
yc[i]<-min(model_2$Parameters[1,1]+model_2$Parameters[2,1]*xc[i]
,model_2$Parameters[3,1])
}
lines(xc,yc, col="red", lwd=1.5) # adding the boundary yield values to plot
crit_ph<-(model_2$Parameters[3,1]-model_2$Parameters[1,1])/model_2$Parameters[2,1]
abline(v=crit_ph, col="red", lty=5) # adding to plot
params3 <- mvrnorm(n = 100000,mu = model_2$Parameters[1:3,1], Sigma = solve(model_2$Hessian[1:3,1:3]))
Hessian<- model_2$Hessian[1:3,1:3]
# Compute the covariance matrix as the inverse of the positive definite matrix
cov_matrix <- solve(Hessian)
params3 <- mvrnorm(n = 100000,mu = model_2$Parameters[1:3,1], Sigma = cov_matrix)#
crit_points3<-(params3[,3]-params3[,1])/params3[,2] # critical points
CI_95ph<-quantile(crit_points3, c(0.025,0.975)) # 95% confidence interval
abline(v=CI_95ph, col="blue", lty=1, lwd=1.5)
polygon(c(CI_95ph[1],CI_95ph[2],CI_95ph[2],CI_95ph[1],CI_95ph[1]), c(0,0,18,18,0),
col=adjustcolor( "red", alpha.f = 0.2),border=NA)
pH_limProb<-pnorm(pH_data, mean = mean(crit_points3), sd = sd(crit_points3))
head(pH_limProb)
x2 <- predict(yj, newdata = vals2[,1], inverse = TRUE)# back-transforming the pH data
plot(x2,vals2[,2], xlab=expression(bold("pH")),
ylab=expression(bold("Yield/ t ha"^-1)), col="grey",
pch=16)
xc2 <- predict(yj, newdata = xc, inverse = TRUE)# back-transforming the pH data
lines(xc2,yc, col="red", lwd=1.5) # boundary line
abline(v=predict(yj, newdata = crit_ph, inverse = TRUE), col="red") # critical pH
CI_95 <- predict(yj, newdata = quantile(crit_points3, c(0.025,0.975)), inverse = TRUE)# back-transforming CI
polygon(c(CI_95[1],CI_95[2],CI_95[2],CI_95[1],CI_95[1]), c(0,0,18,18,0),
col=adjustcolor( "red", alpha.f = 0.2),border=NA) # the confidence interval on plot
legend("bottomright", legend = c("Boundary line", "95% CI"),
lty = c(1,NA), pch = c(NA,15), lwd = c(1.5, NA),
col = c("red",col=adjustcolor( "red", alpha.f = 0.2) ))
yieldlim0<-limfactor(P,pH)
yieldlim<-yieldlim0[[1]]
yieldlim$P_limProb<-P_limProb
yieldlim$pH_limProb<-pH_limProb
head(yieldlim)
props<- prop.table(table(yieldlim$Lim_factor))
pie(props, main="",
labels = paste(names(props), "\n",scales::percent(as.vector(unname(props)))),
cex = 0.8,col = gray(seq(0.4, 1.0, length.out = 6)))
