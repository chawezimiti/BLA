bf=theta[6]
yf<-unlist(lapply(x,FUN=trap3,ar=ar,br=br,ym=ym, yn=yn, af=af, bf=bf))
err<-sum((y-yf)^2)/length(x)
return(err)
}
parscale3<-function(a,x,y){
eps=1e-4
nr<-length(a)
part<-vector("numeric",nr)
for (i in 1:nr){
del<-rep(0,nr)
del[i]<-eps
part[i]<-(rss3((a+del),x,y)-rss3((a),x,y))/eps
}
return(part)
}
#initial values are optimised using optim function
ooo<-optim(theta,rss3,x=newdata5$x,y=newdata5$y,method=optim.method)
scale<-1/abs( parscale3(ooo$par,x=newdata5$x,y=newdata5$y))
oo<-optim(ooo$par,rss3,x=newdata5$x,y=newdata5$y,method=optim.method,control = list(parscale = scale))
ifelse(any(is.nan(oo$par))==T, oo<-ooo, oo<-oo) #rescalling sometimes produces NaN
# and hence this make it to use the original values in ooo. re-investigate this
arf=oo$par[1]
brf=oo$par[2]
ymf=oo$par[3]
ynf=oo$par[4]
aff=oo$par[5]
bff=oo$par[6]
if(plot==TRUE){
xfine=seq(min(x,na.rm = T),max(x,na.rm = T),(max(x,na.rm = T)-min(x,na.rm = T))/((max(x,na.rm = T)-min(x,na.rm = T))*line_smooth))  #needs attention
yfit<-lapply(xfine,FUN=trap3,ar=arf,br=brf,ym=ymf,yn=ynf,af=aff,bf=bff)
yfit<-unlist(yfit)
lines(xfine,yfit,lwd=lwd,col=bl_col)
}
estimates<-matrix(NA,length(theta),1,dimnames=list(c(),c("Estimate")))
estimates[,1]<-c(arf,brf,ymf, ynf, aff, bff)
rownames(estimates)<-c("\u03B2\u2081","\u03B2\u2082","\u03B2\u20801","\u03B2\u20802","\u03B2\u2083","\u03B2\u2084")
RMS<-oo$value
Equation<-noquote("y = {\u03B2\u20801/1+[exp(\u03B2\u2082*(\u03B2\u2081-x))]} - {\u03B2\u20801/1+[exp(\u03B2\u2084*(\u03B2\u2083-x))]} ")
Result<-list(Model=BLMod,Equation=Equation, Parameters=estimates, RMS=RMS, B.points=dataset)
class(Result) <- "cm" #necessary for only printing only part of the output
return(Result)
}
########### OWN CUSTOM FUNCTION ####################################
if(model=="other"){
v<-length(theta)
Equation<-equation # to print equation in output
theta<-unname(theta) # removes names from theta
### three parameters ####
if(v==3){
rss4<-function(theta,x,y,equation){
a=theta[1]
b=theta[2]
c=theta[3]
equation=equation
yf<-do.call(equation, c(list(x=x),list(a,b,c)))
err<-sum((y-yf)^2)/length(x)
return(err)
}
##scaling
parscale4<-function(k,x,y,equation){
eps=1e-4
nr<-length(k)
part<-vector("numeric",nr)
equation=equation
for (i in 1:nr){
del<-rep(0,nr)
del[i]<-eps
part[i]<-(rss4((k+del),x,y,equation)-rss4((k),x,y,equation))/eps
}
return(part)
}
#initial values are optimised using optim function
ooo<-optim(theta,rss4,x=newdata5$x,y=newdata5$y,method=optim.method,equation=equation)
scale<-1/abs( parscale4(ooo$par,x=newdata5$x,y=newdata5$y, equation=equation))
oo<-optim(ooo$par,rss4,x=newdata5$x,y=newdata5$y,method=optim.method,
control = list(parscale = scale), equation=equation)
ifelse(any(is.nan(oo$par))==T, oo<-ooo, oo<-oo) #rescalling sometimes produces NaN
# and hence this make it to use the original values in ooo. re-investigate this
af=oo$par[1]
bf=oo$par[2]
cf=oo$par[3]
if(plot==TRUE){
xfine<-seq(min(x,na.rm = T),max(x,na.rm = T),(max(x,na.rm = T)-min(x,na.rm = T))/((max(x,na.rm = T)-min(x,na.rm = T))*line_smooth))
yfit<-do.call(equation, c(list(x=xfine),list(a=af,b=bf,c=cf)))
yfit<-unlist(yfit)
lines(xfine,yfit,lwd=lwd,col=bl_col)
}
estimates<-matrix(NA,length(theta),1,dimnames=list(c(),c("Estimate")))
estimates[,1]<-c(af,bf,cf)
rownames(estimates)<-c("a","b","c")
RMS<-oo$value
Parameters<-list(Model=BLMod,Equation=equation,Parameters=estimates, RMS=RMS, Boundary_points= newdata5)
class(Parameters) <- "cm" #necessary for only printing only part of the output
return(Parameters)
}
### four parameters ####
if(v==4){
rss4<-function(theta,x,y,equation){
a=theta[1]
b=theta[2]
c=theta[3]
d=theta[4]
equation=equation
yf<-do.call(equation, c(list(x=x),list(a,b,c,d)))
err<-sum((y-yf)^2)/length(x)
return(err)
}
##scaling
parscale4<-function(k,x,y,equation){
eps=1e-4
nr<-length(k)
part<-vector("numeric",nr)
equation=equation
for (i in 1:nr){
del<-rep(0,nr)
del[i]<-eps
part[i]<-(rss4((k+del),x,y,equation)-rss4((k),x,y,equation))/eps
}
return(part)
}
#initial values are optimised using optim function
ooo<-optim(theta,rss4,x=newdata5$x,y=newdata5$y,method=optim.method,equation=equation)
scale<-1/abs( parscale4(ooo$par,x=newdata5$x,y=newdata5$y, equation=equation))
oo<-optim(ooo$par,rss4,x=newdata5$x,y=newdata5$y,method=optim.method,
control = list(parscale = scale), equation=equation)
ifelse(any(is.nan(oo$par))==T, oo<-ooo, oo<-oo) #rescalling sometimes produces NaN
# and hence this make it to use the original values in ooo. re-investigate this
af=oo$par[1]
bf=oo$par[2]
cf=oo$par[3]
df=oo$par[4]
if(plot==TRUE){
xfine<-seq(min(x,na.rm = T),max(x,na.rm = T),(max(x,na.rm = T)-min(x,na.rm = T))/((max(x,na.rm = T)-min(x,na.rm = T))*line_smooth))
yfit<-do.call(equation, c(list(x=xfine),list(a=af,b=bf,c=cf, d=df)))
yfit<-unlist(yfit)
lines(xfine,yfit,lwd=lwd,col=bl_col)
}
estimates<-matrix(NA,length(theta),1,dimnames=list(c(),c("Estimate")))
estimates[,1]<-c(af,bf,cf,df)
rownames(estimates)<-c("a","b","c","d")
RMS<-oo$value
Parameters<-list(Model=BLMod,Equation=equation,Parameters=estimates, RMS=RMS, Boundary_points= newdata5)
class(Parameters) <- "cm" #necessary for only printing only part of the output
return(Parameters)
}
### five parameters ####
if(v==5){
rss4<-function(theta,x,y,equation){
a=theta[1]
b=theta[2]
c=theta[3]
d=theta[4]
e=theta[5]
equation=equation
yf<-do.call(equation, c(list(x=x),list(a,b,c,d,e)))
err<-sum((y-yf)^2)/length(x)
return(err)
}
##scaling
parscale4<-function(k,x,y,equation){
eps=1e-4
nr<-length(k)
part<-vector("numeric",nr)
equation=equation
for (i in 1:nr){
del<-rep(0,nr)
del[i]<-eps
part[i]<-(rss4((k+del),x,y,equation)-rss4((k),x,y,equation))/eps
}
return(part)
}
#initial values are optimised using optim function
ooo<-optim(theta,rss4,x=newdata5$x,y=newdata5$y,method=optim.method,equation=equation)
scale<-1/abs( parscale4(ooo$par,x=newdata5$x,y=newdata5$y, equation=equation))
oo<-optim(ooo$par,rss4,x=newdata5$x,y=newdata5$y,method=optim.method,
control = list(parscale = scale), equation=equation)
ifelse(any(is.nan(oo$par))==T, oo<-ooo, oo<-oo) #rescalling sometimes produces NaN
# and hence this make it to use the original values in ooo. re-investigate this
af=oo$par[1]
bf=oo$par[2]
cf=oo$par[3]
df=oo$par[4]
ef=oo$par[5]
if(plot==TRUE){
xfine<-seq(min(x,na.rm = T),max(x,na.rm = T),(max(x,na.rm = T)-min(x,na.rm = T))/((max(x,na.rm = T)-min(x,na.rm = T))*line_smooth))
yfit<-do.call(equation, c(list(x=xfine),list(a=af,b=bf,c=cf, d=df, e=ef)))
yfit<-unlist(yfit)
lines(xfine,yfit,lwd=lwd,col=bl_col)
}
estimates<-matrix(NA,length(theta),1,dimnames=list(c(),c("Estimate")))
estimates[,1]<-c(af,bf,cf, df,ef)
rownames(estimates)<-c("a","b","c","d","e")
RMS<-oo$value
Parameters<-list(Model=BLMod,Equation=equation,Parameters=estimates, RMS=RMS, Boundary_points= newdata5)
class(Parameters) <- "cm" #necessary for only printing only part of the output
return(Parameters)}
}
}
model2<-blbin2(x,y, bins,theta = theta,model = "trapezium",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="grey", plot=TRUE,
bin_type=="moving")
points(100,100)
plot(100,100)
gx<-locator(200)
plot(gx$x,gx$y)
plot(100,100)
gx<-locator(200)
plot(gx$x,gx$y)
startValues("lp")
devtools::load_all(".")
blbin(gx$x,gx$y, bins = c(60,130,10),model="explore")
blbin(gx$x,gx$y, bins = c(60,130,10),model="lp", theta=c(1,2.5,106))
blbin(gx$x,gx$y, bins = c(60,130,10),model="lp", theta=c(2.5,1,106))
x<-soil$P
x<-log(x)
y<-soil$yield
plot(x,y)
vals_ur<-matrix(NA,length(x),2) #Create a matrix with x and y as required by the bag plot function
vals_ur[,1]<-x
vals_ur[,2]<-y
bag<-bagplot(vals_ur, ylim=c(0,20), show.whiskers =F,create.plot = TRUE) # run the bagplot function
legend("topright", c("bag","loop","outliers", "d.median"),
pch = c(15,15,16,8),col=c("blue","lightblue","red","red"),
cex=0.7)
vals<-rbind(bag$pxy.bag,bag$pxy.outer)
x<-vals[,1]
y<-vals[,2]
bins<-c(1.61,4.74,0.313, 0.313)
theta<-c(4.75, 3.23, 13.3, 24.87,-2.95 )
model2<-blbin2(x,y, bins,theta = theta,model = "explore",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="grey", plot=TRUE,
bin_type=="moving")
model2<-blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="grey", plot=TRUE,
bin_type=="moving")
blbin(gx$x,gx$y, bins = c(60,130,10),model="lp", theta=c(2.5,1,106))
bins<-c(1.61,4.74,0.313, 0.313)
theta<-c(4.75, 3.23, 13.3, 24.87,-2.95 )
model2<-blbin(x,y, bins,theta = theta,model = "explore")
blbin(gx$x,gx$y, bins = c(60,130,10),model="lp", theta=c(2.5,1,106))
blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="grey", plot=TRUE)
blbin(x,y, bins,theta = theta,model = "explore")
blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99)
blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99,xlab=expression("Phosphorus/ mg L"^-1),
expression("Phosphorus/ln(mg L"^-1*")"))
blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99,xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"))
blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99,xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"),
pch=16)
blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99,xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="grey")
blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99,xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="grey", plot=TRUE)
blbin(x,y, bins,theta = theta,model = "trapezium",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="grey")
blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="grey")
blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="grey")
blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="red")
blbin(x,y, bins,theta = theta,model = "trapezium",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="red")
x<-vals[,1]
devtools::load_all(".")
x<-soil$P
x<-log(x)
y<-soil$yield
plot(x,y)
vals_ur<-matrix(NA,length(x),2) #Create a matrix with x and y as required by the bag plot function
vals_ur[,1]<-x
vals_ur[,2]<-y
bag<-bagplot(vals_ur, ylim=c(0,20), show.whiskers =F,create.plot = TRUE) # run the bagplot function
legend("topright", c("bag","loop","outliers", "d.median"),
pch = c(15,15,16,8),col=c("blue","lightblue","red","red"),
cex=0.7)
vals<-rbind(bag$pxy.bag,bag$pxy.outer)
x<-vals[,1]
y<-vals[,2]
bins<-c(1.61,4.74,0.313, 0.313)
theta<-c(4.75, 3.23, 13.3, 24.87,-2.95 )
blbin(x,y, bins,theta = theta,model = "trapezium",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="red")
devtools::load_all(".")
bins<-c(1.61,4.74,0.313, 0.313)
theta<-c(4.75, 3.23, 13.3, 24.87,-2.95 )
blbin(x,y, bins,theta = theta,model = "trapezium",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="red")
bins<-c(1.61,4.74,0.313)
theta<-c(4.75, 3.23, 13.3, 24.87,-2.95 )
blbin(x,y, bins,theta = theta,model = "trapezium",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="red")
blbin(gx$x,gx$y, bins = c(60,130,10),model="lp", theta=c(2.5,1,106))
blbin(gx$x,gx$y, bins = c(60,130,10,5),model="lp", theta=c(2.5,1,106))
devtools::load_all(".")
x<-soil$P
x<-log(x)
y<-soil$yield
plot(x,y)
vals_ur<-matrix(NA,length(x),2) #Create a matrix with x and y as required by the bag plot function
vals_ur[,1]<-x
vals_ur[,2]<-y
bag<-bagplot(vals_ur, ylim=c(0,20), show.whiskers =F,create.plot = TRUE) # run the bagplot function
legend("topright", c("bag","loop","outliers", "d.median"),
pch = c(15,15,16,8),col=c("blue","lightblue","red","red"),
cex=0.7)
vals<-rbind(bag$pxy.bag,bag$pxy.outer)
x<-vals[,1]
y<-vals[,2]
bins<-c(1.61,4.74,0.313)
theta<-c(4.75, 3.23, 13.3, 24.87,-2.95 )
blbin(x,y, bins,theta = theta,model = "trapezium",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="red")
mean(x)
mean(y)
col(x,y)
cor(x,y)
vals<-data.frame(x,y)
vals
cbvn(vals, theta=theta2, mode="lp", sigh=0.7)
theta2<-c(4.75, 3.23, 13.3, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
cbvn(vals, theta=theta2, mode="lp", sigh=0.7)
devtools::load_all(".")
cbvn(vals, theta=theta2, mode="lp", sigh=0.7)
devtools::load_all(".")
cbvn(vals, theta=theta2, mode="lp", sigh=0.7)
cbvn(vals, theta=theta2, mode="lp", sigh=0.7)
devtools::load_all(".")
theta2<-c(4.75, 3.23, 13.3, 24.87,-2.95, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
cbvn(vals, theta=theta2, mode="trapezium", sigh=0.7)
devtools::load_all(".")
beef<-function(x,a,b,c){
return(min(beta0,beta1+beta2*x))
}
vals<-data.frame(x,y)
theta2<-c(4.75, 3.23, 13.3, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
beef<-function(x,a,b,c){
return(min(beta0,beta1+beta2*x))
}
vals<-data.frame(x,y)
theta2<-c(4.75, 3.23, 13.3, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
cbvn(vals, equation=beef, theta=theta2, mode="trapezium", sigh=0.7)
cbvn(vals, equation=beef, theta=theta2, mode="other", sigh=0.7)
cbvn(vals, equation=beef, theta=theta2, mode="other", sigh=0.7)
cbvn(vals, equation=beef, theta=theta2, model="other", sigh=0.7)
cbvn(vals, equation=beef, theta=theta2, model="other", sigh=0.7)
theta2
devtools::load_all(".")
theta2<-c(4.75, 3.23, 13.3, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
cbvn(vals, equation=beef, theta=theta2, model="other", sigh=0.7)
beef<-function(x,a,b,c){
return(min(a,b+c*x))
}
vals<-data.frame(x,y)
theta2<-c(13.3, 4.75, 3.23, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
cbvn(vals, equation=beef, theta=theta2, model="other", sigh=0.7)
match.fun(beef)
devtools::load_all(".")
beef2<-function(x,a,b,c,d,e){
return(min(a,b+c*x,d+e*x))
}
vals<-data.frame(x,y)
theta2<-c(13.3, 4.75, 3.23, 24.87,-2.95, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
cbvn(vals, equation=beef2, theta=theta2, model="other", sigh=0.7)
devtools::load_all(".")
beef2<-function(x,a,b,c,d,e){
return(min(a,b+c*x,d+e*x))
}
vals<-data.frame(x,y)
theta2<-c(13.3, 4.75, 3.23, 24.87,-2.95, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
cbvn(vals, equation=beef2, theta=theta2, model="other", sigh=0.7)
devtools::load_all(".")
beef2<-function(x,a,b,c,d,e){
return(min(a,b+c*x,d+e*x))
}
vals<-data.frame(x,y)
theta2<-c(13.3, 4.75, 3.23, 24.87,-2.95, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
cbvn(vals, equation=beef2, theta=theta2, model="other", sigh=0.7)
# Custom 3 parameter function
beef<-function(x,a,b,c){
return(min(a,b+c*x))
}
vals<-data.frame(x,y)
theta2<-c(13.3, 4.75, 3.23, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
cbvn(vals, equation=beef, theta=theta2, model="other", sigh=0.7)
vals<-data.frame(x,y)
theta2<-c(13.3, 4.75, 3.23, 24.87,-2.95, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
cbvn(vals, equation=beef2, theta=theta2, model="other", sigh=0.7)
mean(x)
mean(y)
sd(x)
sd(y)
devtools::load_all(".")
beef2<-function(x,a,b,c,d,e){
return(min(a,b+c*x,d+e*x))
}
vals<-data.frame(x,y)
theta2<-c(13.3, 4.75, 3.23, 24.87,-2.95, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
cbvn(vals, equation=beef2, theta=theta2, model="other", sigh=0.7)
huck<-function(x){}
beef2<-function(x,a,b,c,d,e){
return(min(a,b+c*x,d+e*x))
}
nack<-beef2
beef2
devtools::load_all(".")
x<-soil$P
x<-log(x)
y<-soil$yield
plot(x,y)
vals_ur<-matrix(NA,length(x),2) #Create a matrix with x and y as required by the bag plot function
vals_ur[,1]<-x
vals_ur[,2]<-y
bag<-bagplot(vals_ur, ylim=c(0,20), show.whiskers =F,create.plot = TRUE) # run the bagplot function
legend("topright", c("bag","loop","outliers", "d.median"),
pch = c(15,15,16,8),col=c("blue","lightblue","red","red"),
cex=0.7)
vals<-rbind(bag$pxy.bag,bag$pxy.outer)
x<-vals[,1]
y<-vals[,2]
# Custom 3 parameter function
beef<-function(x,a,b,c){
return(min(a,b+c*x))
}
vals<-data.frame(x,y)
theta2<-c(13.3, 4.75, 3.23, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
cbvn(vals, equation=beef, theta=theta2, model="other", sigh=0.7)
devtools::load_all(".")
cbvn(vals, equation=beef, theta=theta2, model="other", sigh=0.7)
devtools::load_all(".")
beef2<-function(x,a,b,c,d,e){
return(min(a,b+c*x,d+e*x))
}
vals<-data.frame(x,y)
theta2<-c(13.3, 4.75, 3.23, 24.87,-2.95, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
cbvn(vals, equation=beef2, theta=theta2, model="other", sigh=0.7)
vals<-data.frame(x,y)
devtools::load_all(".")
vals<-data.frame(x,y)
theta2<-c(4.75, 3.23, 13.3, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
cbvn(vals, theta=theta2, mode="lp", sigh=0.7)
theta2<-c(4.75, 3.23, 13.3, 24.87,-2.95, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
cbvn(vals, theta=theta2, mode="trapezium", sigh=0.7)
devtools::load_all(".")
theta2<-c(4.75, 3.23, 13.3, 24.87,-2.95, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
cbvn(vals, theta=theta2, mode="trapezium", sigh=0.7)
devtools::load_all(".")
devtools::load_all(".")
vals<-data.frame(x,y)
theta2<-c(4.75, 3.23, 13.3, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
ble_profile(vals,sigh=c(0.6,0.7),theta=theta2,model="lp")
ble_profile(vals,sigh=c(0.6,0.7),theta=theta2,model="lp")
devtools::load_all(".")
ble_profile(vals,sigh=c(0.6,0.7),theta=theta2,model="lp")
devtools::load_all(".")
# Custom 3 parameter function
beef<-function(x,a,b,c){
return(min(a,b+c*x))
}
vals<-data.frame(x,y)
theta2<-c(13.3, 4.75, 3.23, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
ble_profile(vals,sigh=c(0.6),theta=theta2,model="other",equation=beef)
