# Estimated parameters
estimated_params <- result$par
estimated_params
ypred<-mitcherlich(seq(0.0,0.3,0.01), estimated_params[1],estimated_params[2], estimated_params[3])
lines(seq(0.0,0.3,0.01),ypred, col="red")
# Initial parameter values
initial_params <- c(0.49,150, 0.4)
# Initial parameter values
initial_params <- c(0.49,2.2, 0.4)
# Optimize the objective function
result <- optim(par = initial_params, fn = objective, x = x, y = y)
# Estimated parameters
estimated_params <- result$par
estimated_params
ypred<-mitcherlich(seq(0.0,0.3,0.01), estimated_params[1],estimated_params[2], estimated_params[3])
lines(seq(0.0,0.3,0.01),ypred, col="red")
0.23/0.5
startValues("blm")
0.515/0.19
x<-v$x
y<-v$y
plot(0.2,0.5)
points(x,y, col="red")
# Initial parameter values
initial_params <- c(0.5,2.7, 0.46)
# Optimize the objective function
result <- optim(par = initial_params, fn = objective, x = x, y = y)
# Estimated parameters
estimated_params <- result$par
estimated_params
ypred<-mitcherlich(seq(0.0,0.3,0.01), estimated_params[1],estimated_params[2], estimated_params[3])
lines(seq(0.0,0.3,0.01),ypred, col="red")
plot(0.2,0.5, xlim=c(0,2), ylim=c(0,1))
lines(seq(0.0,0.3,0.01),ypred, col="red")
ypred<-mitcherlich(seq(0.0,1,0.01), estimated_params[1],estimated_params[2], estimated_params[3])
lines(seq(0.0,1,0.01),ypred, col="red")
noquote("y = \u03B2\u2081 + \u03B2\u2080 (1-exp(-x/\u03B2\u2082))")
\u03B2\u2082x
"y = \u03B2\u2081 + \u03B2\u2082x + \u03B2\u2083x\u00B2"
"y = \u03B2\u2080 + \u03B2\u2081*\u03B2\u2082\u00Bx"
"y = \u03B2\u2080 + \u03B2\u2081*\u03B2\u2082\u00B2"
"y = \u03B2\u2080 + \u03B2\u2081*\u03B2\u2082\u00B3"
"y = \u03B2\u2080 + \u03B2\u2081*\u03B2\u2082\u00Bx"
"y = \u03B2\u2080 + \u03B2\u2081*\u03B2\u2082^x"
"y = \u03B2\u2080 + \u03B2\u2081*\u03B2\u2082x"
"y = \u03B2\u2080 + \u03B2\u2081*\u03B2\u2082\u00Bx"
"y = \u03B2\u2080 + \u03B2\u2081*\u03B2\u2082x"
Equation<-noquote("y = \u03B2\u2080 + \u03B2\u2081*\u03B2\u2082^x")
Equation
plot(0.5,10)
v<-locator(8)
x<-v$x
y<-v$y
points(x,y, col="red")
startValues("blm")
startValues("logistic",8)
0.46/10
30/0.46
# Initial parameter values
initial_params <- c(10,65, 0.05)
# Optimize the objective function
result <- optim(par = initial_params, fn = objective, x = x, y = y)
# Estimated parameters
estimated_params <- result$par
estimated_params
ypred<-mitcherlich(seq(0.0,1,0.01), estimated_params[1],estimated_params[2], estimated_params[3])
lines(seq(0.0,1,0.01),ypred, col="red")
30/0.05
"y = min(\u03B2\u2081 + \u03B2\u2082*x, \u03B2\u2080, \u03B2\u2083 + \u03B2\u2084*x)\n\n"
"y = min(\u03B2\u2081 + \u03B2\u2082*x, \u03B2\u2080, \u03B2\u2083 + \u03B2\u2084*x)"
abs(-1)
abs(min(c(-1,-0.5)))
min(abs(-0.1,-1))
abs(c(-0.1,-1))
min(abs(c(-0.1,-1)))
plot(10,10)
6/4
6-(1.5*6)
12-15
"\u03B2\u2081"
devtools::load_all(".")
startValues("mit",8)
devtools::load_all(".")
plot(0.5,10)
points(x,y, col="red")
lines(seq(0.0,1,0.01),ypred, col="red")
startValues("mit",8)
estimated_params
devtools::load_all(".")
plot(0.5,10)
points(x,y, col="red")
lines(seq(0.0,1,0.01),ypred, col="red")
startValues("mit",8)
df<-data.frame(x=c(1,2,3,4,5), y=c(1,3,5,3,2))
plot(df)
df$x[which(df$y==max(df$y)),]
df$x
df$x[which(df$y==max(df$y))]
df<-data.frame(x=c(1,2,3,4,5,6), y=c(1,3,5,5,3,2))
plot(df)
df$x[which(df$y==max(df$y))]
mean(df$x[which(df$y==max(df$y))])
mean(3)
devtools::load_all(".")
devtools::load_all(".")
startValues("schmidt",8)
plot(0.500,18)
v<-locator(8)
x<-v$x
y<-v$y
points(x,y, col="red")
# Define the Schmidt function
schmidt <- function(x, a, b, c) {
y <- a + b * (x - c)^2
return(y)
}
# Objective function to minimize - sum of squared differences between observed and predicted values
objective <- function(params, x, y) {
a <- params[1]
b <- params[2]
c <- params[3]
predicted <- schmidt(x, a, b, c)
error <- sum((y - predicted)^2)
return(error)
}
# Initial parameter values
initial_params <- c(19,0, 0.55)
# Optimize the objective function
result <- optim(par = initial_params, fn = objective, x = x, y = y)
# Estimated parameters
estimated_params <- result$par
estimated_params
ypred<-schmidt(seq(0.300,0.700,0.010), estimated_params[1],estimated_params[2], estimated_params[3])
lines(seq(0.300,0.700,0.010),ypred)
startValues("blm")
startValues("logistic",8)
4/18
18.5+6
24.5/0.22
plot(0.500,18)
v<-locator(8)
x<-v$x
y<-v$y
points(x,y, col="red")
startValues("blm")
startValues("logistic",8)
0.72/20
77/0.036
77/0.72
# Initial parameter values
initial_params <- c(20,2138, 0.5)
# Optimize the objective function
result <- optim(par = initial_params, fn = objective, x = x, y = y)
# Estimated parameters
estimated_params <- result$par
estimated_params
ypred<-schmidt(seq(0.300,0.700,0.010), estimated_params[1],estimated_params[2], estimated_params[3])
lines(seq(0.300,0.700,0.010),ypred)
startValues("blm")
50/0.036
50/0.72
schmidt(0, estimated_params[1],estimated_params[2], estimated_params[3])
2/0.036
38/20
77/1.9
# Initial parameter values
initial_params <- c(20,2138, 0.5)
# Optimize the objective function
result <- optim(par = initial_params, fn = objective, x = x, y = y)
# Estimated parameters
estimated_params <- result$par
estimated_params
ypred<-schmidt(seq(0.300,0.700,0.010), estimated_params[1],estimated_params[2], estimated_params[3])
lines(seq(0.300,0.700,0.010),ypred)
# Initial parameter values
initial_params <- c(20,0, 0.5)
# Optimize the objective function
result <- optim(par = initial_params, fn = objective, x = x, y = y)
# Estimated parameters
estimated_params <- result$par
estimated_params
ypred<-schmidt(seq(0.300,0.700,0.010), estimated_params[1],estimated_params[2], estimated_params[3])
lines(seq(0.300,0.700,0.010),ypred)
lines(seq(0.300,0.700,0.010),ypred, col="red")
devtools::load_all(".")
startValues("schmidt",8)
# Initial parameter values
initial_params <- c(20,-205, 0.45)
# Optimize the objective function
result <- optim(par = initial_params, fn = objective, x = x, y = y)
# Estimated parameters
estimated_params <- result$par
estimated_params
ypred<-schmidt(seq(0.300,0.700,0.010), estimated_params[1],estimated_params[2], estimated_params[3])
lines(seq(0.300,0.700,0.010),ypred, col="blue")
plot(0.500,36)
v<-locator(8)
x<-v$x
y<-v$y
points(x,y, col="red")
startValues("schmidt",8)
# Initial parameter values
initial_params <- c(36,-10, 0.45)
# Optimize the objective function
result <- optim(par = initial_params, fn = objective, x = x, y = y)
# Estimated parameters
estimated_params <- result$par
estimated_params
ypred<-schmidt(seq(0.300,0.700,0.010), estimated_params[1],estimated_params[2], estimated_params[3])
lines(seq(0.300,0.700,0.010),ypred, col="blue")
# Initial parameter values
initial_params <- c(36,0, 0.45)
# Optimize the objective function
result <- optim(par = initial_params, fn = objective, x = x, y = y)
# Estimated parameters
estimated_params <- result$par
estimated_params
# Initial parameter values
initial_params <- c(36,5, 0.45)
# Optimize the objective function
result <- optim(par = initial_params, fn = objective, x = x, y = y)
# Estimated parameters
estimated_params <- result$par
estimated_params
ypred<-schmidt(seq(0.300,0.700,0.010), estimated_params[1],estimated_params[2], estimated_params[3])
lines(seq(0.300,0.700,0.010),ypred, col="blue")
# Initial parameter values
initial_params <- c(36,1, 0.45)
# Optimize the objective function
result <- optim(par = initial_params, fn = objective, x = x, y = y)
# Estimated parameters
estimated_params <- result$par
estimated_params
ypred<-schmidt(seq(0.300,0.700,0.010), estimated_params[1],estimated_params[2], estimated_params[3])
lines(seq(0.300,0.700,0.010),ypred, col="blue")
# Initial parameter values
initial_params <- c(36,-1, 0.45)
# Optimize the objective function
result <- optim(par = initial_params, fn = objective, x = x, y = y)
# Estimated parameters
estimated_params <- result$par
estimated_params
ypred<-schmidt(seq(0.300,0.700,0.010), estimated_params[1],estimated_params[2], estimated_params[3])
lines(seq(0.300,0.700,0.010),ypred, col="blue")
plot(0.800,4)
v<-locator(8)
plot(1,4)
v<-locator(8)
x<-v$x
y<-v$y
points(x,y, col="red")
# Initial parameter values
initial_params <- c(4.6,1, 0.55)
# Optimize the objective function
result <- optim(par = initial_params, fn = objective, x = x, y = y)
# Estimated parameters
estimated_params <- result$par
estimated_params
ypred<-schmidt(seq(0.600,1.700,0.010), estimated_params[1],estimated_params[2], estimated_params[3])
lines(seq(0.600,1.700,0.010),ypred, col="blue")
startValues("schmidt",8)
estimated_params
#usethis::use_readme_rmd() # creates a readme file
devtools::build_readme()
devtools::load_all(".")
x<-soil$P
x<-log(x)
y<-soil$yield
plot(x,y)
vals_ur<-matrix(NA,length(x),2) #Create a matrix with x and y as required by the bag plot function
vals_ur[,1]<-x
vals_ur[,2]<-y
bag<-bagplot(vals_ur, ylim=c(0,20), show.whiskers =F,create.plot = TRUE) # run the bagplot function
legend("topright", c("bag","loop","outliers", "d.median"),
pch = c(15,15,16,8),col=c("blue","lightblue","red","red"),
cex=0.7)
vals<-rbind(bag$pxy.bag,bag$pxy.outer)
x<-vals[,1]
y<-vals[,2]
vals<-data.frame(x,y)
beef<-function(x,a,b,c){
return(min(a,b+c*x))
}
vals<-data.frame(x,y)
theta2<-c(13.3, 4.75, 3.23, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
result<-cbvn(vals, equation=beef, theta=theta2, model="other", sigh=0.7)
result
predictBL(result, c(3.5,4))
result$Equation
do.call(result$Equation, c(list(x=x),as.list(c(result$Parameters[,1]))))
c(list(x=x)
)
as.list(c(result$Parameters[,1]))
as.list(c(result$Parameters[,1]))[1:3]
do.call(result$Equation, c(list(x=x),as.list(c(result$Parameters[,1]))[1:3]))
x
as.list(c(result$Parameters[,1]))
do.call(result$Equation, c(list(x=x),as.list(c(result$Parameters[,1]))[1:3]))
x
result$Parameters[,1]
do.call(result$Equation, c(list(x=x),as.list(c(result$Parameters[1:3,1]))))
c(list(x=x),as.list(c(result$Parameters[1:3,1])))
result$Equation
devtools::load_all(".")
predictBL(result, c(3.5,4))
predictBL(result, c(2))
theta1<-c(4.75, 3.23, 13.3, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
result2<-cbvn(vals, theta=theta1, mode="lp", sigh=0.7)
predictBL(result, c(2,3,4))
do.call(result$Equation, c(list(x=x),result$Parameters[1:3,1]))
result <- list(
Parameters = matrix(c(1, 2, 3), ncol = 1),
Equation = function(x, a, b, c) {
a + b * x + c * x^2  # Example equation
}
)
# Vector of x values
x <- seq(from = 0, to = 10, length.out = 100)
# Extract the parameters from the matrix and convert to a named list
params <- as.list(result$Parameters[1:3, 1])
names(params) <- c("a", "b", "c")
# Prepare the argument list
args <- c(list(x = x), params)
args
# Use do.call to apply the function to the arguments
y <- do.call(result$Equation, args)
y
params
result$Equation
result <- list(
Parameters = matrix(c(1, 2, 3), ncol = 1),
Equation = function(x, a, b, c) {
pmin(a, b * x + c)  # Use pmin for element-wise minimum
}
)
# Vector of x values
x <- seq(from = 0, to = 10, length.out = 100)
# Extract the parameters from the matrix and convert to a named list
params <- as.list(result$Parameters[1:3, 1])
names(params) <- c("a", "b", "c")
# Prepare the argument list
args <- c(list(x = x), params)
# Use do.call to apply the function to the arguments
y <- do.call(result$Equation, args)
# Print the result
print(y)
x
# Vector of x values
x <- rnorm(5,9,50)
# Extract the parameters from the matrix and convert to a named list
params <- as.list(result$Parameters[1:3, 1])
names(params) <- c("a", "b", "c")
# Prepare the argument list
args <- c(list(x = x), params)
# Use do.call to apply the function to the arguments
y <- do.call(result$Equation, args)
# Print the result
print(y)
result <- list(
Parameters = matrix(c(1, 2, 3), ncol = 1),
Equation = function(x, a, b, c) {
min(a, b * x + c)  # Use pmin for element-wise minimum
}
)
# Vector of x values
x <- rnorm(5,9,50)
# Extract the parameters from the matrix and convert to a named list
params <- as.list(result$Parameters[1:3, 1])
names(params) <- c("a", "b", "c")
# Prepare the argument list
args <- c(list(x = x), params)
# Use do.call to apply the function to the arguments
y <- do.call(result$Equation, args)
# Print the result
print(y)
result <- list(
Parameters = matrix(c(1, 2, 3), ncol = 1),
Equation = function(x, a, b, c) {
pmin(a, b * x + c)  # Use pmin for element-wise minimum
}
)
# Extract the parameters from the matrix and convert to a named list
params <- as.list(result$Parameters[1:3, 1])
names(params) <- c("a", "b", "c")
# Prepare the argument list
args <- c(list(x = x), params)
# Use do.call to apply the function to the arguments
y <- do.call(result$Equation, args)
# Print the result
print(y)
vals<-rbind(bag$pxy.bag,bag$pxy.outer)
x<-vals[,1]
y<-vals[,2]
beef<-function(x,a,b,c){
return(pmin(a,b+c*x))
}
vals<-data.frame(x,y)
theta2<-c(13.3, 4.75, 3.23, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
result<-cbvn(vals, equation=beef, theta=theta2, model="other", sigh=0.7)
predictBL(result, c(2,3,4))
devtools::load_all(".")
predictBL(result, c(2,3,4))
beef<-function(x,a,b,c){
return(min(a,b+c*x))
}
vals<-data.frame(x,y)
theta2<-c(13.3, 4.75, 3.23, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
result<-cbvn(vals, equation=beef, theta=theta2, model="other", sigh=0.7)
predictBL(result, c(2,3,4))
devtools::load_all(".")
predictBL(result, c(2,3,4))
devtools::load_all(".")
predictBL(result, c(2,3,4))
devtools::load_all(".")
beef<-function(x,a,b,c){
return(min(a,b+c*x))
}
vals<-data.frame(x,y)
theta2<-c(13.3, 4.75, 3.23, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
result<-cbvn(vals, equation=beef, theta=theta2, model="other", sigh=0.7)
predictBL(result, c(2,3,4))
result$Parameters[1:3,1]
result$Parameters
result$Distribution
devtools::load_all(".")
vals<-data.frame(x,y)
theta2<-c(13.3, 4.75, 3.23, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
result<-cbvn(vals, equation=beef, theta=theta2, model="other", sigh=0.7)
predictBL(result, c(2,3,4))
beef2<-function(x,a,b,c,d,e){
return(min(a,b+c*x,d+e*x))
}
vals<-data.frame(x,y)
theta2<-c(13.3, 4.75, 3.23, 24.87,-2.95, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
res<-cbvn(vals, equation=beef2, theta=theta2, model="other", sigh=0.7)
res
predictBL(res, c(2,3,4))
res$Distribution
"\u03BC"
"\u03BC\u2093\"
"\u03BC\u2093"
"\u03BC\u2093\x"
"\u03BC\u2093x"
beef3<-function(x,a,b,c,d){
return(a-b*exp(-c*x^d))
}
vals<-data.frame(x,y)
theta2<-c(13.3, 100,0.1,0.2 , mean(x), mean(y), sd(x) , sd(y), cor(x,y))
res2<-cbvn(vals, equation=beef2, theta=theta2, model="other", sigh=0.7)
beef3<-function(x,a,b,c,d){
return(a-b*exp(-c*x^d))
}
vals<-data.frame(x,y)
theta2<-c(13.3, 100,0.1,0.2 , mean(x), mean(y), sd(x) , sd(y), cor(x,y))
res2<-cbvn(vals, equation=beef2, theta=theta2, model="other", sigh=0.7)
predictBL(res, c(2,3,4))
res2<-cbvn(vals, equation=beef2, theta=theta2, model="other", sigh=0.7)
length(theta2)
beef3<-function(x,a,b,c,d){
return(a-b*exp(-c*x^d))
}
vals<-data.frame(x,y)
theta2<-c(13.3, 100,0.1,0.2, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
res2<-cbvn(vals, equation=beef2, theta=theta2, model="other", sigh=0.7)
res2<-cbvn(vals, equation=beef3, theta=theta2, model="other", sigh=0.7)
theta2<-c(13.3, 1,0.1,0.2, mean(x), mean(y), sd(x) , sd(y), cor(x,y))
res2<-cbvn(vals, equation=beef3, theta=theta2, model="other", sigh=0.7)
predictBL(res2, c(2,3,4))
res2
custom_function<-function(x,a,b,c){
y<- a - b*(x-c)^2
}
theta<-c(13.5,3,3.3)
model4<-bolides(x,y, theta = theta,model = "other",
equation=custom_function,
xlab=expression("Phosphorus/mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, ylim=c(3.8,14.5), col="grey",bp_col="grey")
predictBL(model4, c(2,3,4))
tools::package_dependencies("BLA", recursive = TRUE)
install.packages("rhub")
result<-rhub::check_for_cran()
?rhubv2`
check_for_cran(
platforms = c("debian-gcc-release", "windows-x86_64-release", "macos-highsierra-release")
)
library(rhub)
check_for_cran(
platforms = c("debian-gcc-release", "windows-x86_64-release", "macos-highsierra-release")
)
platforms <- c("debian-gcc-release", "windows-x86_64-release", "macos-highsierra-release")
# Perform the check
check_results <- check(platforms = platforms)
# Print the results
print(check_results)
platforms <- c(
"debian-gcc-release",
"windows-x86_64-release",
"macos-highsierra-release"
)
# Perform the check
check_results <- rhub::check(platforms = platforms)
# Print a summary of the results
print(check_results)
?rhubv2
tools::package_dependencies("BLA", recursive = TRUE)
?cov.rob
cov.robust <- cov.rob(dat)
library(MASS, lib.loc = "C:/Program Files/R/R-4.2.2/library")
?cov.rob
detach("package:MASS", unload = TRUE)
devtools::load_all(".")
