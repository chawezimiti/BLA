return(yout)
}}
if(model=="logistic"){
Equation<-noquote("y = \u03B2\u2080/(1+exp(\u03B2\u2082(\u03B2\u2081-x)))")
trap1<-function(x,ar,br,ym){
yr<-ym/(1+exp(br*(ar-x)))
yout<-yr
return(yout)
}
}
if(model=="logisticfm"){
Equation<-noquote("y = \u03B2\u2080/1+[\u03B2\u2081exp(-\u03B2\u2082*x)]")
trap1<-function(x,ar,br,ym){
yr<-ym/(1+(ar*exp(-br*x)))
yout<-yr
return(yout)
}
}
if(model=="inv-logistic"){
Equation<-noquote("y = \u03B2\u2080/(1+exp(\u03B2\u2082(\u03B2\u2081-x)))")
trap1<-function(x,ar,br,ym){
yr<-ym-(ym/(1+exp(br*(ar-x))))
yout<-yr
return(yout)
}
}
if(model=="qd"){
Equation<-noquote("y = \u03B2\u2081 + \u03B2\u2082x + \u03B2\u2083x\u00B2")
trap1<-function(x,ar,br,ym){
yr<- ar + br*x + ym*x*x
yout<-yr
return(yout)
}
}
if(model=="mit"){
Equation<-noquote("y = \u03B2\u2081 + \u03B2\u2080 (1-exp(-x/\u03B2\u2082))")
trap1<-function(x,ar,br,ym){
yr<-ar+ym*(1-exp(-x/br))
yout<-yr
return(yout)
}
}
if(model=="schmidt"){
Equation<-noquote("y = \u03B2\u2080 - \u03B2\u2081 (1-\u03B2\u2082)\u00B2)")
trap1<-function(x,ar,br,ym){
yr<-ym-ar*(x-br)*(x-br)
yout<-yr
return(yout)
}
}
rss1<-function(theta,x,y){
ar=theta[1]
br=theta[2]
ym=theta[3]
yf<-unlist(lapply(x,FUN=trap1,ar=ar,br=br,ym=ym))
err<-sum((y-yf)^2)/length(x)
return(err)
}
##scaling
parscale1<-function(a,x,y){
eps=1e-4
nr<-length(a)
part<-vector("numeric",nr)
for (i in 1:nr){
del<-rep(0,nr)
del[i]<-eps
part[i]<-(rss1((a+del),x,y)-rss1((a),x,y))/eps
}
return(part)
}
#initial values are optimised using optim function
ooo<-optim(theta,rss1,x=newdata5$x,y=newdata5$y,method=optim.method)
scale<-1/abs( parscale1(ooo$par,x=newdata5$x,y=newdata5$y))
oo<-optim(ooo$par,rss1,x=newdata5$x,y=newdata5$y,method=optim.method,control = list(parscale = scale))
ifelse(any(is.nan(oo$par))==T, oo<-ooo, oo<-oo) #rescalling sometimes produces NaN
# and hence this make it to use the original values in ooo. re-investigate this
arf=oo$par[1]
brf=oo$par[2]
ymf=oo$par[3]
if(plot==TRUE){
xfine=seq(min(x,na.rm = T),max(x,na.rm = T),(max(x,na.rm = T)-min(x,na.rm = T))/((max(x,na.rm = T)-min(x,na.rm = T))*line_smooth))
yfit<-lapply(xfine,FUN=trap1,ar=arf,br=brf,ym=ymf)
yfit<-unlist(yfit)
lines(xfine,yfit,lwd=lwd,col=bl_col)
}
estimates<-matrix(NA,length(theta),1,dimnames=list(c(),c("Estimate")))
estimates[,1]<-c(arf,brf,ymf)
if(model=="qd"){
rownames(estimates)<-c("\u03B2\u2081","\u03B2\u2082","\u03B2\u2083")}else{
rownames(estimates)<-c("\u03B2\u2081","\u03B2\u2082","\u03B2\u2080")
}
RMS<-oo$value
Parameters<-list(Model=BLMod,Equation=Equation,Parameters=estimates, RMS=RMS, Boundary_points= newdata5)
class(Parameters) <- "cm" #necessary for only printing only part of the output
return(Parameters)
}
################ Fitting five parameter Trapezium model##########################
if(model=="trapezium"){
v<-length(theta)
if(v>5) warning("theta has more than five values")
if(v<5) stop("theta has less than five values")
trap2<-function(x,ar,br,ym,af,bf){
yr<-ar+br*x
yf<-af+bf*x
yout<-min(c(yr,yf,ym))
return(yout)
}
rss2<-function(theta,x,y){
ar=theta[1]
br=theta[2]
ym=theta[3]
af=theta[4]
bf=theta[5]
yf<-unlist(lapply(x,FUN=trap2,ar=ar,br=br,ym=ym,af=af,bf=bf))
err<-sum((y-yf)^2)/length(x)
return(err)
}
parscale2<-function(a,x,y){
eps=1e-4
nr<-length(a)
part<-vector("numeric",nr)
for (i in 1:nr){
del<-rep(0,nr)
del[i]<-eps
part[i]<-(rss2((a+del),x,y)-rss2((a),x,y))/eps
}
return(part)
}
#initial values are optimised
ooo<-optim(theta,rss2,x=newdata5$x,y=newdata5$y,method=optim.method)   #find LS estimate of theta given data in x,yobs
scale<-1/abs( parscale2(ooo$par,x=newdata5$x,y=newdata5$y))
oo<-optim(ooo$par,rss2,x=newdata5$x,y=newdata5$y,method=optim.method,control = list(parscale = scale))
ifelse(any(is.nan(oo$par))==T, oo<-ooo, oo<-oo) #rescalling sometimes produces NaN
# and hence this make it to use the original values in ooo. re-investigate this
arf=oo$par[1]
brf=oo$par[2]
ymf=oo$par[3]
aff=oo$par[4]
bff=oo$par[5]
bp1<-(ymf-arf)/(brf) #estimates of the boundary break points
bp2<-(ymf-aff)/(bff) #estimates of the boundary break points
xfine=seq(min(x,na.rm = T),max(x,na.rm = T),(max(x,na.rm = T)-min(x,na.rm = T))/((max(x,na.rm = T)-min(x,na.rm = T))*line_smooth)) # this needs attention in all methods
yfit<-lapply(xfine,FUN=trap2,ar=arf,br=brf,ym=ymf,af=aff,bf=bff)
yfit<-unlist(yfit)
if(plot==TRUE){lines(xfine,yfit,lwd=lwd,col=bl_col)}
#Parameters<-data.frame(Paramter=c("ar","br","ym","af","bf", "bp1","bp2"), value=c(arf,brf,ymf,aff,bff, bp1,bp2))
estimates<-matrix(NA,length(theta),1,dimnames=list(c(),c("Estimate")))
estimates[,1]<-c(arf,brf,ymf,aff,bff)
rownames(estimates)<-c("\u03B2\u2081","\u03B2\u2082","\u03B2\u2080","\u03B2\u2083","\u03B2\u2084")
RMS<-oo$value
Equation<-noquote("y = min(\u03B2\u2081+ \u03B2\u2082x, \u03B2\u2080, \u03B2\u2083 + \u03B2\u2084x)")
Result<-list(Model=BLMod,Equation=Equation, Parameters=estimates, RMS=RMS, B.points=dataset)
class(Result) <- "cm" #necessary for only printing only part of the output
return(Result)
}
###################### Fitting six parameter logistics  ##############
if(model=="double-logistic"){
v<-length(theta)
if(v>6) warning("theta has more than six values")
if(v<6) stop("theta has less than six values")
trap3<-function(x,ar,br,ym,yn, af, bf){
yr<-ym/(1 + exp((br*(ar-x)))) - yn/(1 + exp((bf*(af-x))))
yout<-yr
return(yout)
}
rss3<-function(theta,x,y){
ar=theta[1]
br=theta[2]
ym=theta[3]
yn=theta[4]
af=theta[5]
bf=theta[6]
yf<-unlist(lapply(x,FUN=trap3,ar=ar,br=br,ym=ym, yn=yn, af=af, bf=bf))
err<-sum((y-yf)^2)/length(x)
return(err)
}
parscale3<-function(a,x,y){
eps=1e-4
nr<-length(a)
part<-vector("numeric",nr)
for (i in 1:nr){
del<-rep(0,nr)
del[i]<-eps
part[i]<-(rss3((a+del),x,y)-rss3((a),x,y))/eps
}
return(part)
}
#initial values are optimised using optim function
ooo<-optim(theta,rss3,x=newdata5$x,y=newdata5$y,method=optim.method)
scale<-1/abs( parscale3(ooo$par,x=newdata5$x,y=newdata5$y))
oo<-optim(ooo$par,rss3,x=newdata5$x,y=newdata5$y,method=optim.method,control = list(parscale = scale))
ifelse(any(is.nan(oo$par))==T, oo<-ooo, oo<-oo) #rescalling sometimes produces NaN
# and hence this make it to use the original values in ooo. re-investigate this
arf=oo$par[1]
brf=oo$par[2]
ymf=oo$par[3]
ynf=oo$par[4]
aff=oo$par[5]
bff=oo$par[6]
if(plot==TRUE){
xfine=seq(min(x,na.rm = T),max(x,na.rm = T),(max(x,na.rm = T)-min(x,na.rm = T))/((max(x,na.rm = T)-min(x,na.rm = T))*line_smooth))  #needs attention
yfit<-lapply(xfine,FUN=trap3,ar=arf,br=brf,ym=ymf,yn=ynf,af=aff,bf=bff)
yfit<-unlist(yfit)
lines(xfine,yfit,lwd=lwd,col=bl_col)
}
estimates<-matrix(NA,length(theta),1,dimnames=list(c(),c("Estimate")))
estimates[,1]<-c(arf,brf,ymf, ynf, aff, bff)
rownames(estimates)<-c("\u03B2\u2081","\u03B2\u2082","\u03B2\u20801","\u03B2\u20802","\u03B2\u2083","\u03B2\u2084")
RMS<-oo$value
Equation<-noquote("y = {\u03B2\u20801/1+[exp(\u03B2\u2082*(\u03B2\u2081-x))]} - {\u03B2\u20801/1+[exp(\u03B2\u2084*(\u03B2\u2083-x))]} ")
Result<-list(Model=BLMod,Equation=Equation, Parameters=estimates, RMS=RMS, B.points=dataset)
class(Result) <- "cm" #necessary for only printing only part of the output
return(Result)
}
########### OWN CUSTOM FUNCTION ####################################
if(model=="other"){
v<-length(theta)
Equation<-equation # to print equation in output
theta<-unname(theta) # removes names from theta
### three parameters ####
if(v==3){
rss4<-function(theta,x,y,equation){
a=theta[1]
b=theta[2]
c=theta[3]
equation=equation
yf<-do.call(equation, c(list(x=x),list(a,b,c)))
err<-sum((y-yf)^2)/length(x)
return(err)
}
##scaling
parscale4<-function(k,x,y,equation){
eps=1e-4
nr<-length(k)
part<-vector("numeric",nr)
equation=equation
for (i in 1:nr){
del<-rep(0,nr)
del[i]<-eps
part[i]<-(rss4((k+del),x,y,equation)-rss4((k),x,y,equation))/eps
}
return(part)
}
#initial values are optimised using optim function
ooo<-optim(theta,rss4,x=newdata5$x,y=newdata5$y,method=optim.method,equation=equation)
scale<-1/abs( parscale4(ooo$par,x=newdata5$x,y=newdata5$y, equation=equation))
oo<-optim(ooo$par,rss4,x=newdata5$x,y=newdata5$y,method=optim.method,
control = list(parscale = scale), equation=equation)
ifelse(any(is.nan(oo$par))==T, oo<-ooo, oo<-oo) #rescalling sometimes produces NaN
# and hence this make it to use the original values in ooo. re-investigate this
af=oo$par[1]
bf=oo$par[2]
cf=oo$par[3]
if(plot==TRUE){
xfine<-seq(min(x,na.rm = T),max(x,na.rm = T),(max(x,na.rm = T)-min(x,na.rm = T))/((max(x,na.rm = T)-min(x,na.rm = T))*line_smooth))
yfit<-do.call(equation, c(list(x=xfine),list(a=af,b=bf,c=cf)))
yfit<-unlist(yfit)
lines(xfine,yfit,lwd=lwd,col=bl_col)
}
estimates<-matrix(NA,length(theta),1,dimnames=list(c(),c("Estimate")))
estimates[,1]<-c(af,bf,cf)
rownames(estimates)<-c("a","b","c")
RMS<-oo$value
Parameters<-list(Model=BLMod,Equation=equation,Parameters=estimates, RMS=RMS, Boundary_points= newdata5)
class(Parameters) <- "cm" #necessary for only printing only part of the output
return(Parameters)
}
### four parameters ####
if(v==4){
rss4<-function(theta,x,y,equation){
a=theta[1]
b=theta[2]
c=theta[3]
d=theta[4]
equation=equation
yf<-do.call(equation, c(list(x=x),list(a,b,c,d)))
err<-sum((y-yf)^2)/length(x)
return(err)
}
##scaling
parscale4<-function(k,x,y,equation){
eps=1e-4
nr<-length(k)
part<-vector("numeric",nr)
equation=equation
for (i in 1:nr){
del<-rep(0,nr)
del[i]<-eps
part[i]<-(rss4((k+del),x,y,equation)-rss4((k),x,y,equation))/eps
}
return(part)
}
#initial values are optimised using optim function
ooo<-optim(theta,rss4,x=newdata5$x,y=newdata5$y,method=optim.method,equation=equation)
scale<-1/abs( parscale4(ooo$par,x=newdata5$x,y=newdata5$y, equation=equation))
oo<-optim(ooo$par,rss4,x=newdata5$x,y=newdata5$y,method=optim.method,
control = list(parscale = scale), equation=equation)
ifelse(any(is.nan(oo$par))==T, oo<-ooo, oo<-oo) #rescalling sometimes produces NaN
# and hence this make it to use the original values in ooo. re-investigate this
af=oo$par[1]
bf=oo$par[2]
cf=oo$par[3]
df=oo$par[4]
if(plot==TRUE){
xfine<-seq(min(x,na.rm = T),max(x,na.rm = T),(max(x,na.rm = T)-min(x,na.rm = T))/((max(x,na.rm = T)-min(x,na.rm = T))*line_smooth))
yfit<-do.call(equation, c(list(x=xfine),list(a=af,b=bf,c=cf, d=df)))
yfit<-unlist(yfit)
lines(xfine,yfit,lwd=lwd,col=bl_col)
}
estimates<-matrix(NA,length(theta),1,dimnames=list(c(),c("Estimate")))
estimates[,1]<-c(af,bf,cf,df)
rownames(estimates)<-c("a","b","c","d")
RMS<-oo$value
Parameters<-list(Model=BLMod,Equation=equation,Parameters=estimates, RMS=RMS, Boundary_points= newdata5)
class(Parameters) <- "cm" #necessary for only printing only part of the output
return(Parameters)
}
### five parameters ####
if(v==5){
rss4<-function(theta,x,y,equation){
a=theta[1]
b=theta[2]
c=theta[3]
d=theta[4]
e=theta[5]
equation=equation
yf<-do.call(equation, c(list(x=x),list(a,b,c,d,e)))
err<-sum((y-yf)^2)/length(x)
return(err)
}
##scaling
parscale4<-function(k,x,y,equation){
eps=1e-4
nr<-length(k)
part<-vector("numeric",nr)
equation=equation
for (i in 1:nr){
del<-rep(0,nr)
del[i]<-eps
part[i]<-(rss4((k+del),x,y,equation)-rss4((k),x,y,equation))/eps
}
return(part)
}
#initial values are optimised using optim function
ooo<-optim(theta,rss4,x=newdata5$x,y=newdata5$y,method=optim.method,equation=equation)
scale<-1/abs( parscale4(ooo$par,x=newdata5$x,y=newdata5$y, equation=equation))
oo<-optim(ooo$par,rss4,x=newdata5$x,y=newdata5$y,method=optim.method,
control = list(parscale = scale), equation=equation)
ifelse(any(is.nan(oo$par))==T, oo<-ooo, oo<-oo) #rescalling sometimes produces NaN
# and hence this make it to use the original values in ooo. re-investigate this
af=oo$par[1]
bf=oo$par[2]
cf=oo$par[3]
df=oo$par[4]
ef=oo$par[5]
if(plot==TRUE){
xfine<-seq(min(x,na.rm = T),max(x,na.rm = T),(max(x,na.rm = T)-min(x,na.rm = T))/((max(x,na.rm = T)-min(x,na.rm = T))*line_smooth))
yfit<-do.call(equation, c(list(x=xfine),list(a=af,b=bf,c=cf, d=df, e=ef)))
yfit<-unlist(yfit)
lines(xfine,yfit,lwd=lwd,col=bl_col)
}
estimates<-matrix(NA,length(theta),1,dimnames=list(c(),c("Estimate")))
estimates[,1]<-c(af,bf,cf, df,ef)
rownames(estimates)<-c("a","b","c","d","e")
RMS<-oo$value
Parameters<-list(Model=BLMod,Equation=equation,Parameters=estimates, RMS=RMS, Boundary_points= newdata5)
class(Parameters) <- "cm" #necessary for only printing only part of the output
return(Parameters)}
}
}
model2<-blbin2(x,y, bins,theta = theta,model = "trapezium",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="grey", plot=TRUE,
bin_type=="moving")
points(100,100)
plot(100,100)
gx<-locator(200)
plot(gx$x,gx$y)
plot(100,100)
gx<-locator(200)
plot(gx$x,gx$y)
startValues("lp")
devtools::load_all(".")
blbin(gx$x,gx$y, bins = c(60,130,10),model="explore")
blbin(gx$x,gx$y, bins = c(60,130,10),model="lp", theta=c(1,2.5,106))
blbin(gx$x,gx$y, bins = c(60,130,10),model="lp", theta=c(2.5,1,106))
x<-soil$P
x<-log(x)
y<-soil$yield
plot(x,y)
vals_ur<-matrix(NA,length(x),2) #Create a matrix with x and y as required by the bag plot function
vals_ur[,1]<-x
vals_ur[,2]<-y
bag<-bagplot(vals_ur, ylim=c(0,20), show.whiskers =F,create.plot = TRUE) # run the bagplot function
legend("topright", c("bag","loop","outliers", "d.median"),
pch = c(15,15,16,8),col=c("blue","lightblue","red","red"),
cex=0.7)
vals<-rbind(bag$pxy.bag,bag$pxy.outer)
x<-vals[,1]
y<-vals[,2]
bins<-c(1.61,4.74,0.313, 0.313)
theta<-c(4.75, 3.23, 13.3, 24.87,-2.95 )
model2<-blbin2(x,y, bins,theta = theta,model = "explore",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="grey", plot=TRUE,
bin_type=="moving")
model2<-blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="grey", plot=TRUE,
bin_type=="moving")
blbin(gx$x,gx$y, bins = c(60,130,10),model="lp", theta=c(2.5,1,106))
bins<-c(1.61,4.74,0.313, 0.313)
theta<-c(4.75, 3.23, 13.3, 24.87,-2.95 )
model2<-blbin(x,y, bins,theta = theta,model = "explore")
blbin(gx$x,gx$y, bins = c(60,130,10),model="lp", theta=c(2.5,1,106))
blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="grey", plot=TRUE)
blbin(x,y, bins,theta = theta,model = "explore")
blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99)
blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99,xlab=expression("Phosphorus/ mg L"^-1),
expression("Phosphorus/ln(mg L"^-1*")"))
blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99,xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"))
blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99,xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"),
pch=16)
blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99,xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="grey")
blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99,xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="grey", plot=TRUE)
blbin(x,y, bins,theta = theta,model = "trapezium",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="grey")
blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="grey")
blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="grey")
blbin(x,y, bins,theta = theta,model = "explore",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="red")
blbin(x,y, bins,theta = theta,model = "trapezium",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="red")
x<-vals[,1]
devtools::load_all(".")
x<-soil$P
x<-log(x)
y<-soil$yield
plot(x,y)
vals_ur<-matrix(NA,length(x),2) #Create a matrix with x and y as required by the bag plot function
vals_ur[,1]<-x
vals_ur[,2]<-y
bag<-bagplot(vals_ur, ylim=c(0,20), show.whiskers =F,create.plot = TRUE) # run the bagplot function
legend("topright", c("bag","loop","outliers", "d.median"),
pch = c(15,15,16,8),col=c("blue","lightblue","red","red"),
cex=0.7)
vals<-rbind(bag$pxy.bag,bag$pxy.outer)
x<-vals[,1]
y<-vals[,2]
bins<-c(1.61,4.74,0.313, 0.313)
theta<-c(4.75, 3.23, 13.3, 24.87,-2.95 )
blbin(x,y, bins,theta = theta,model = "trapezium",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="red")
devtools::load_all(".")
bins<-c(1.61,4.74,0.313, 0.313)
theta<-c(4.75, 3.23, 13.3, 24.87,-2.95 )
blbin(x,y, bins,theta = theta,model = "trapezium",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="red")
bins<-c(1.61,4.74,0.313)
theta<-c(4.75, 3.23, 13.3, 24.87,-2.95 )
blbin(x,y, bins,theta = theta,model = "trapezium",
tau=0.99,
xlab=expression("Phosphorus/ mg L"^-1),
ylab=expression("Phosphorus/ln(mg L"^-1*")"),
pch=16, col="grey", bp_col="red")
blbin(gx$x,gx$y, bins = c(60,130,10),model="lp", theta=c(2.5,1,106))
blbin(gx$x,gx$y, bins = c(60,130,10,5),model="lp", theta=c(2.5,1,106))
