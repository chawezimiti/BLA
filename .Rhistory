na.drop(xmin)
suppressMessages(na.drop(xmin))
plot(x,y)
startValues(model="lp")
devtools::load_all(".")
startValues(model="lp")
startValues(model="blm")
startValues(model="blm")
suppressMessages(startValues(model="blm"))
layout()
beef<- function(x){
plot_layout<-rbind(c(1,1,2),c(1,1,3))
layout(plot_layout)
hist(x)
boxplot(x)
hist(x)
}
beef(rnorm(100,2,1))
beef(rnorm(100,2,1))
hist(rnorm(100,2,1))
par(mfrow=c(1,1))
hist(rnorm(100,2,1))
beef(c("a","b"))
hist(rnorm(100,2,1))
hist(rnorm(100,2,1))
beef<- function(x){
### Setting the graphic space---------------------------------------------------------
old_par <- par(no.readonly = TRUE) # Save the current graphical parameters
on.exit(par(old_par))# Ensure the original graphical parameters are restored on exit
par(mfrow=c(1,2))
##------------------------------------------------------------------------------------
plot_layout<-rbind(c(1,1,2),c(1,1,3))
layout(plot_layout)
hist(x)
boxplot(x)
hist(x)
}
beef(rnorm(100,2,1))
hist(rnorm(100,2,1))
par(mfrow=c(1,1))
hist(rnorm(100,2,1))
beef(c("a","b"))
hist(rnorm(100,2,1))
getOption("scipen")
# Load necessary library
library(tools)
# Read the DESCRIPTION file
desc <- read.dcf("DESCRIPTION")
# Extract the Description field
description_field <- desc[,"Description"]
# Check for leading or trailing spaces
has_spaces <- grepl("^\\s|\\s$", description_field)
has_spaces
if (has_spaces) {
cat("The Description field has leading or trailing spaces.\n")
} else {
cat("The Description field is clean.\n")
}
# Check for multiple spaces within the description
if (grepl("\\s{2,}", description_field)) {
cat("The Description field contains multiple spaces in a row.\n")
} else {
cat("The Description field does not contain multiple spaces in a row.\n")
}
# Function to wrap text at a specified width
wrap_text <- function(text, width = 90) {
paste(strwrap(text, width = width), collapse = "\n ")
}
# Read the DESCRIPTION file
desc <- read.dcf("DESCRIPTION")
# Extract and wrap the Description field
description_field <- desc[,"Description"]
wrapped_description <- wrap_text(description_field)
# Update the DESCRIPTION file with the wrapped Description field
desc[,"Description"] <- wrapped_description
# Write the updated DESCRIPTION file back
write.dcf(desc, "DESCRIPTION", width = 80) #
# Write the updated DESCRIPTION file back
write.dcf(desc, "DESCRIPTION", width = 80) #
# Function to wrap text at a specified width
wrap_text <- function(text, width = 90) {
paste(strwrap(text, width = width), collapse = "\n ")
}
# Read the DESCRIPTION file
desc <- read.dcf("DESCRIPTION")
# Extract and wrap the Description field
description_field <- desc[,"Description"]
wrapped_description <- wrap_text(description_field)
# Update the DESCRIPTION file with the wrapped Description field
desc[,"Description"] <- wrapped_description
# Write the updated DESCRIPTION file back
write.dcf(desc, "DESCRIPTION", width = 80) #
######################
# usethis::use_package("MASS")
# usethis::use_package("mvtnorm")
# usethis::use_import_from("aplpack", "bagplot")
#
usethis::use_tidy_description() # puts the description in an acceptable form
######################
# usethis::use_package("MASS")
# usethis::use_package("mvtnorm")
# usethis::use_import_from("aplpack", "bagplot")
#
usethis::use_tidy_description() # puts the description in an acceptable form
#usethis::use_pkgdown()
pkgdown::build_site() # to build the site
#usethis::use_pkgdown()
pkgdown::build_site() # to build the site
devtools::check_win_devel()
######################
# usethis::use_package("MASS")
# usethis::use_package("mvtnorm")
# usethis::use_import_from("aplpack", "bagplot")
#
usethis::use_tidy_description() # puts the description in an acceptable form
######################
# usethis::use_package("MASS")
# usethis::use_package("mvtnorm")
# usethis::use_import_from("aplpack", "bagplot")
#
usethis::use_tidy_description() # puts the description in an acceptable form
devtools::load_all(".")
x<-evapotranspiration$`ET(mm)`
y<-evapotranspiration$`yield(t/ha)`
expl_boundary(x,y,10,10) # recommendation is to set simulations to greater than 1000
suppressMessages(expl_boundary(x,y,10,10) )
devtools::load_all(".")
expl_boundary(x,y,10,10) # recommendation is to set simulations to greater than 1000
expl_boundary(x,y,10,1000) # recommendation is to set simulations to greater than 1000
plot(x,y)
startValues(model="blm")
suppressMessages(startValues(model="blm"))
devtools::check_win_devel()
devtools::check_win_devel()
start<-c(0.5,0.02, mean(x), mean(y), sd(x), sd(y), cor(x,y))
start
devtools::load_all(".")
data<-data.frame(x,y)
start<-c(0.5,0.02, mean(x), mean(y), sd(x), sd(y), cor(x,y))
cbvn(data, start=start, model = "blm")
cbvn(data, start=start, model = "blm", sigh=0.6)
cbvn(data, start=start, model = "blm", sigh=0.5)
cbvn(data, start=start, model = "blm", sigh=0.4)
cbvn(data, start=start, model = "blm", sigh=0.55)
cbvn(data, start=start, model = "blm", sigh=0.6)
cbvn(data, start=start, model = "blm", sigh=0.5)
cbvn(data, start=start, model = "blm", sigh=0.51)
cbvn(data, start=start, model = "blm", sigh=0.51,
xlab=expression("ET/ mm ha"^-1),
ylab=expression("Yield/ ton ha"^-1))
x<-evapotranspiration$`ET(mm)`
y<-evapotranspiration$`yield(t/ha)`
data<-data.frame(x,y)
start<-c(0.5,0.02,289.6,2.4,83.7,1.07,0.287)
sigh <- c(0.5,0.6,0.7,0.8,0.9)
ble_profile(data,start=start,model = "blm", sigh = sigh)
sigh <- c(0.5,0.7,0.8,0.9)
ble_profile(data,start=start,model = "blm", sigh = sigh)
sigh <- c(0.6,0.7,0.8,0.9)
ble_profile(data,start=start,model = "blm", sigh = sigh)
sigh <- c(0.7,0.8,0.9)
ble_profile(data,start=start,model = "blm", sigh = sigh)
sigh <- c(0.6,0.7,0.8,0.9)
ble_profile(data,start=start,model = "blm", sigh = sigh)
cbvn(data, start=start, model = "blm", sigh=0.9,
xlab=expression("ET/ mm ha"^-1),
ylab=expression("Yield/ ton ha"^-1))
cbvn(data, start=start, model = "blm", sigh=0.51,
xlab=expression("ET/ mm ha"^-1),
ylab=expression("Yield/ ton ha"^-1))
cbvn(data, start=start, model = "blm", sigh=0.51,
xlab=expression("ET/ mm ha"^-1),
ylab=expression("Yield/ ton ha"^-1), line_smooth = 100)
cbvn(data, start=start, model = "blm", sigh=0.51,
xlab=expression("ET/ mm ha"^-1),
ylab=expression("Yield/ ton ha"^-1),
line_smooth = 100)
cbvn(data, start=start, model = "blm", sigh=0.51,
xlab=expression("ET/ mm ha"^-1),
ylab=expression("Yield/ ton ha"^-1),
line_smooth = 1000)
cbvn(data, start=start, model = "blm", sigh=0.51,
xlab=expression("ET/ mm ha"^-1),
ylab=expression("Yield/ ton ha"^-1),
line_smooth = 100)
devtools::check_win_devel()
mean(x)
mean(y)
sd(x)
sd(y)
cor(x,y)
summastat("x")
plot(x,y)
usethis::use_version('patch')
usethis::use_version('patch')
devtools::submit_cran()
usethis::use_github_release()
usethis::use_dev_version()
usethis::use_lifecycle_badge("stable")
#usethis::use_readme_rmd() # creates a readme file
devtools::build_readme()
#usethis::use_readme_rmd() # creates a readme file
devtools::build_readme()
load("C:/Users/stxcm28/OneDrive - The University of Nottingham/Desktop/BLA/data/SoilpH.rda")
setwd("C:/Users/stxcm28/OneDrive - The University of Nottingham/Desktop/BLA_Package_illustration")
soil<-read.csv("soilxx.csv")
head(soil)
use_data(soil)
library(devtools)
use_data(soil)
setwd("C:/Users/stxcm28/OneDrive - The University of Nottingham/Desktop/BLA")
use_data(soil)
setwd("C:/Users/stxcm28/OneDrive - The University of Nottingham/Desktop/BLA")
use_data(soil)
detach("package:devtools", unload = TRUE)
library(devtools)
use_data(soil)
setwd("C:/Users/stxcm28/OneDrive - The University of Nottingham/Desktop/BLA")
use_data(soil)
soil<-read.csv("soilxx.csv")
library(devtools)
head(soil)
use_data(soil)
use_r("soil")
devtools::load_all(".")
library(MASS)
library(bestNormalize)
library(aplpack)
dat<-data.frame(x=log(soil$P), y=soil$yield) #Input for bagplot is a dataframe of x and y.
bag<-bagplot(dat, na.rm = FALSE, approx.limit = 300,
show.outlier = TRUE, show.whiskers = F,
show.looppoints = TRUE, show.bagpoints = TRUE,
show.loophull = TRUE, show.baghull = TRUE,
create.plot = TRUE, add = FALSE, pch = 16, cex = 0.4,
dkmethod = 2, precision = 1, verbose = FALSE)
vals<-rbind(bag$pxy.bag,bag$pxy.outer) # new data set without bivariate outliers
pH_bc <- box_cox_transform(soil$pH, lambda)
yj <- yeojohnson(soil$pH)
pH_yj <- yj$x.t
summastat(pH_yj) # can be assumed to be from normal distribution
dat2<-data.frame(pH_yj,soil$yield)
bag<-bagplot(dat2, na.rm = FALSE, approx.limit = 300,
show.outlier = TRUE, show.whiskers = F,
show.looppoints = TRUE, show.bagpoints = TRUE,
show.loophull = TRUE, factor = 2.7, show.baghull = TRUE,
create.plot = TRUE, add = FALSE, pch = 16, cex = 0.4,
dkmethod = 2, precision = 1, verbose = FALSE)
bag<-bagplot(dat2, na.rm = FALSE, approx.limit = 300,
show.outlier = TRUE, show.whiskers = F,
show.looppoints = TRUE, show.bagpoints = TRUE,
show.loophull = TRUE, factor = 3, show.baghull = TRUE,
create.plot = TRUE, add = FALSE, pch = 16, cex = 0.4,
dkmethod = 2, precision = 1, verbose = FALSE)
vals2<-rbind(bag$pxy.bag,bag$pxy.outer) # new excludes bivariate outliers
cbvn(vals2, start = start, sigh=0.5, model = "lp",
xlab=expression("pH/tranformed YeoJohnson"),
ylab=expression("Yield/ t ha"^-1),
pch=16, col="grey")
start<-c(20,4.6,13.3, 0.003, 9.27, 0.99,1.76, 0.118)
cbvn(vals2, start = start, sigh=0.5, model = "lp",
xlab=expression("pH/tranformed YeoJohnson"),
ylab=expression("Yield/ t ha"^-1),
pch=16, col="grey")
#'
#' Miti. c., Milne. A. E., Giller. K. E. and Lark. R. M (2024). Exploration of data
#' for analysis using boundary line methodology. Computers and Electronics in Agriculture
#' 219 (2024) 108794.
#'
#' @examples
#' x<-evapotranspiration$`ET(mm)`
#' y<-evapotranspiration$`yield(t/ha)`
#' expl_boundary(x,y,10,100) # recommendation is to set simulations to greater than 1000
#'
expl_boundary<-function(x,y,shells=10,simulations=1000,method="sd-enclidean",plot=TRUE,...){
if(simulations>=1000) message("Note: This function might take longer to execute when running a large number of simulations.\n")
## Selection of the x_min and x_max index values----------------------------------------
upper.peel<-function(peel){
min.x.index<-which(peel[,2]==max(peel[,2][which(peel[,1]==min(peel[,1]))]) & peel[,1]==min(peel[,1])) # selection of min
max.x.index<-which(peel[,2]==max(peel[,2][which(peel[,1]==max(peel[,1]))]) & peel[,1]==max(peel[,1])) # and max.x.index
if(min.x.index<max.x.index){                                                                          # even when two values
op<-peel[min.x.index:max.x.index,]                                                                  # occur. The highest is used
}else{
op<-rbind(peel[(min.x.index:nrow(peel)),],
peel[(1:max.x.index),]
)
}
return(op)
}
## Removing NA'S from the data ---------------------------------------------------------
data<- data.frame(x=x,y=y)
test<-which(is.na(data$x)==TRUE|is.na(data$y)==TRUE)
if(length(test)>0){
data1<-data[-which(is.na(data$x)==TRUE|is.na(data$y)==TRUE),]}else{
data1<-data
}
x<-data1$x
y<-data1$y
dat<-cbind(x,y)
## setting the output area -------------------------------------------------------------
if(plot==TRUE){
old_par <- par(no.readonly = TRUE) # Save the current graphical parameters
on.exit(par(old_par))# Ensure the original graphical parameters are restored on exit
plot_layout<-rbind(c(1,1,2),c(1,1,3))
layout(plot_layout)
plot(dat,...)}
## Determination of the convex hull-----------------------------------------------------
peels<-list()
left<-list()
right<-list()
n<-length(dat[,1]) #: sample size
Sigma<-cov(dat)
for(i in 1:shells){
ch.index<-chull(dat) # find convex hull (index values for points)
p1<-dat[ch.index,]   # extract peel 1
p1_2<-p1[!duplicated(p1), ]
p1.upper<-upper.peel(p1_2)
p1.upperx<-data.frame(x=p1.upper[,1],y=p1.upper[,2])
ifelse( p1.upperx[1,2]!=max(p1.upperx$y),
peels[[i]]<-split(p1.upperx,ifelse(p1.upperx$x<p1.upperx$x[which(p1.upperx$y==max(p1.upperx$y))],0,1)),
peels[[i]]<-split(p1.upperx,ifelse(p1.upperx$x<= p1.upperx$x[which(p1.upperx$y==max(p1.upperx$y))],0,1)))
index.func<-function(x,y){
del<-list()
for(i in 1:length(y[,1])){
del[[i]]<-which(x[,1]==y[,1][i]& x[,2]==y[,2][i])
}
del
d<-unlist(del, recursive = TRUE, use.names = TRUE)
d
}
dat<-dat[-index.func(dat,p1.upper),]
}
for(i in 1:shells){
left[[i]]<-peels[[i]][[1]]
right[[i]]<-peels[[i]][[2]]
df1 <- do.call("rbind", left)
df2 <- do.call("rbind", right)
}
if(plot==TRUE){
points(df1$x,df1$y,col="red", pch=16)
points(df2$x,df2$y,col="blue", pch=16)}
pointL<-df1
pointR<-df2
## Clustering matrics-------------------------------------------------------------------
#### 1. Calculating the euclidean distance of vertices to center------------------------
ED1_sd<-sd(sqrt((mean(x)-df1[,1])^2+(mean(y)-df1[,2])^2))
ED2_sd<-sd(sqrt((mean(x)-df2[,1])^2+(mean(y)-df2[,2])^2))
#### 2. Calculating the perimeter and of the boundary points----------------------------
perimL <- AP(df1)$Perimeter # left section
perimR <- AP(df2)$Perimeter# right section
areaL <- AP(df1)$Area # left section
areaR <- AP(df2)$Area# right section
polygonL <- AP(df1)$Polygon # left section
polygonR <- AP(df2)$Polygon # right section
### Monte Carlo simulation for evidence testing  ---------------------------------------
ED1_sim<-list()
ED2_sim<-list()
ED_all_sd_rise<-vector()
ED_all_sd_fall<-vector()
perimL_sim<-vector()
perimR_sim<-vector()
areaL_sim<-vector()
areaR_sim<-vector()
for(j in 1:simulations){
peels<-list()
left<-list()
right<-list()
## simulation of data using summary statistics of the available data------------------
dat<-mvrnorm(n,mu=c(mean(x),mean(y)),Sigma)
## Removal of outliers from the simulated data----------------------------------------
cov.robust <- cov.rob(dat)
md <- mahalanobis(dat, cov.robust$center, cov.robust$cov)
threshold <- qchisq(0.995, df=ncol(dat))  # 1% significance level
outliers <- md > threshold
dat <- dat[!outliers, ]
## Determination of convex hull for the simulated data--------------------------------
for(i in 1:shells){
ch.index<-chull(dat) # find convex hull (index values for points)
p1<-dat[ch.index,]   # extract peel 1
p1_2<-p1[!duplicated(p1), ] # removes duplicate values i.e if two rows have same x and y values
p1.upper<-upper.peel(p1_2)
p1.upperx<-data.frame(x=p1.upper[,1],y=p1.upper[,2])
ifelse( p1.upperx[1,2]!=max(p1.upperx$y),
peels[[i]]<-split(p1.upperx,ifelse(p1.upperx$x<p1.upperx$x[which(p1.upperx$y==max(p1.upperx$y))],0,1)),
peels[[i]]<-split(p1.upperx,ifelse(p1.upperx$x<= p1.upperx$x[which(p1.upperx$y==max(p1.upperx$y))],0,1)))
index.func<-function(x,y){
del<-list()
for(i in 1:length(y[,1])){
del[[i]]<-which(x[,1]==y[,1][i]& x[,2]==y[,2][i])
}
del
d<-unlist(del, recursive = TRUE, use.names = TRUE) # convert all the indexed rows into one vector
d
}
dat<-dat[-index.func(dat,p1.upper),]
}
for(i in 1:shells){
left[[i]]<-peels[[i]][[1]]
right[[i]]<-peels[[i]][[2]]
}
df1 <- do.call("rbind", left)
df2 <- do.call("rbind", right)
# 1. Enclidean distance measure-------------------------------------------------------
ED1_2<-sqrt((mean(x)-df1[,1])^2+(mean(y)-df1[,2])^2)
ED2_2<-sqrt((mean(x)-df2[,1])^2+(mean(y)-df2[,2])^2)
ED1_sim[[j]]<-ED1_2
ED2_sim[[j]]<-ED2_2
# 2. Perimeter measure---------------------------------------------------------------
perimL_2 <- AP(df1)$Perimeter # left section
perimR_2 <- AP(df2)$Perimeter# right section
areaL_2 <- AP(df1)$Area # left section
areaR_2 <- AP(df2)$Area# right section
perimL_sim[j]<-perimL_2
perimR_sim[j]<-perimR_2
areaL_sim[j]<-areaL_2
areaR_sim[j]<-areaR_2
}
#---------------------------------------------------------------------------------------
for(i in 1:simulations){
ED_all_sd_rise[i]<-sd(ED1_sim[[i]])
}
for(i in 1:simulations){
ED_all_sd_fall[i]<-sd(ED2_sim[[i]])
}
## Calculating test indices-------------------------------------------------------------
### 1. sd test indices------------------------------------------------------------------
p_sd_rise<-length(which(ED_all_sd_rise<=ED1_sd))/length(ED_all_sd_rise)
p_sd_fall<-length(which(ED_all_sd_fall<=ED2_sd))/length(ED_all_sd_fall)
MeanSDr<-mean(ED_all_sd_rise)
MeanSDf<-mean(ED_all_sd_fall)
### 2. Perimeter area test indices-----------------------------------------------------------
p_perim_rise<-length(which(perimL_sim<=perimL))/length(perimL_sim)
p_perim_fall<-length(which(perimR_sim<=perimR))/length(perimR_sim)
p_area_rise<-length(which(areaL_sim<=areaL))/length(areaL_sim)
p_area_fall<-length(which(areaR_sim<=areaR))/length(areaR_sim)
MeanperimL<-mean(perimL_sim)
MeanperimR<-mean(perimR_sim)
MeanareaL<-mean(areaL_sim)
MeanareaR<-mean(areaR_sim)
## Output preparation-------------------------------------------------------------------
if(method=="sd-enclidean"){
Index<-c("sd","sd")
Section<-c("Left","Right")
value<-c(ED1_sd,ED2_sd)
Mean<-c(MeanSDr,MeanSDf)
p_value<-c(p_sd_rise, p_sd_fall)
## Plotting the data points for visualization-------------------------------------------
if(plot==TRUE){
hist(ED_all_sd_rise,freq = FALSE, xlab="sd",main = "Left")
lines(density(ED_all_sd_rise), lwd = 1, col = "red")
abline(v=ED1_sd, col="red",lty=2)
hist(ED_all_sd_fall,freq = FALSE,xlab="sd",main = "Right")
lines(density(ED_all_sd_fall), lwd = 1, col = "red")
abline(v=ED2_sd, col="red",lty=2)
}
}
if(method=="Perimeter"){
Index<-c("Perimeter","Perimeter")
Section<-c("Left","Right")
value<-c(perimL,perimR)
Mean<-c(MeanperimL,MeanperimR)
p_value<-c(p_perim_rise, p_perim_fall)
## Plotting the data points for visualization-------------------------------------------
if(plot==TRUE){
hist(perimL_sim,freq = FALSE, xlab="Perimeter",main = "Left")
lines(density(perimL_sim), lwd = 1, col = "red")
abline(v=perimL, col="red",lty=2)
hist(perimR_sim,freq = FALSE,xlab="Perimeter",main = "Right")
lines(density(perimR_sim), lwd = 1, col = "red")
abline(v=perimR, col="red",lty=2)
}
}
if(method=="Area"){
Index<-c("Area","Area")
Section<-c("Left","Right")
value<-c(areaL,areaR)
Mean<-c(MeanareaL,MeanareaR)
p_value<-c(p_area_rise, p_area_fall)
## Plotting the data points for visualization-----------------------------------------
if(plot==TRUE){
hist(areaL_sim,freq = FALSE, xlab="Perimeter",main = "Left")
lines(density(areaL_sim), lwd = 1, col = "red")
abline(v=areaL, col="red",lty=2)
hist(areaR_sim,freq = FALSE,xlab="Perimeter",main = "Right")
lines(density(areaR_sim), lwd = 1, col = "red")
abline(v=areaR, col="red",lty=2)
}
}
result<-data.frame(Index,Section,value,Mean,p_value)
return(result)
}
yj <- yeojohnson(soil$pH)
pH_yj <- yj$x.t
summastat(pH_yj) # can be assumed to be from normal distribution
dat2<-data.frame(pH_yj,soil$yield)
bag<-bagplot(dat2, na.rm = FALSE, approx.limit = 300,
show.outlier = TRUE, show.whiskers = F,
show.looppoints = TRUE, show.bagpoints = TRUE,
show.loophull = TRUE, factor = 3, show.baghull = TRUE,
create.plot = TRUE, add = FALSE, pch = 16, cex = 0.4,
dkmethod = 2, precision = 1, verbose = FALSE)
vals2<-rbind(bag$pxy.bag,bag$pxy.outer) # new excludes bivariate outliers
x<-vals2[,1]
y<-vals2[,2]
devtools::load_all(".")
x<-vals2[,1]
y<-vals2[,2]
x<-vals2[,1]
y<-vals2[,2]
expl_boundary(x,y,10,1000, method = "Perimeter") # there is evidence of bounding structures
devtools::load_all(".")
expl_boundary(x,y,10,1000, method = "Perimeter") # there is evidence of bounding structures
expl_boundary(x,y,10,1000, method = "Perimeter") # there is evidence of bounding structures
