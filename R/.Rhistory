br <- params[2]
yf <- unlist(lapply(x, FUN = trap, ar = ar, br = br))
err <- sum((y - yf)^2) / length(x)
return(err)
}
if (optim.method == "DEoptim") {
# Define bounds if not provided
if (is.null(lower)) lower <- c(-Inf, -Inf)
if (is.null(upper)) upper <- c(Inf, Inf)
# Run DEoptim
result <- DEoptim::DEoptim(rss, lower = lower, upper = upper,
DEoptim.control(trace = TRUE),
x = newdata5$x, y = newdata5$y)
# Extract optimized parameters
arf <- result$optim$bestmem[1]
brf <- result$optim$bestmem[2]
RMS <- result$optim$bestval
} else {
# Default to optim
ooo <- optim(start, rss, x = newdata5$x, y = newdata5$y, method = optim.method)
arf <- ooo$par[1]
brf <- ooo$par[2]
RMS <- ooo$value
}
if (plot == TRUE) {
xfine <- seq(min(x, na.rm = TRUE), max(x, na.rm = TRUE),
length.out = line_smooth)
yfit <- unlist(lapply(xfine, FUN = trap, ar = arf, br = brf))
lines(xfine, yfit, lwd = lwd, col = bl_col)
}
estimates <- matrix(c(arf, brf), nrow = 2, ncol = 1,
dimnames = list(c("\u03B2\u2081", "\u03B2\u2082"),
c("Estimate")))
Equation <- noquote("y = \u03B2\u2081 + \u03B2\u2082x")
Parameters <- list(Model = BLMod, Equation = Equation,
Parameters = estimates, RMS = RMS,
Boundary_points = newdata6)
class(Parameters) <- "wm" # Necessary for only printing part of the output
return(Parameters)
}
# Additional models and logic remain unchanged...
}
install.packages("DEoptim")
library(DEoptim)
# Example data
x <- 1:10
y <- 2 + 3 * x + rnorm(10)
# Call the function with DEoptim
result <- bolides(x, y, model = "blm", start = c(1, 1),
optim.method = "DEoptim", lower = c(0, 0), upper = c(10, 10))
# Call the function with DEoptim
result <- bolides2(x, y, model = "blm", start = c(1, 1),
optim.method = "DEoptim", lower = c(0, 0), upper = c(10, 10))
# Call the function with DEoptim
result <- bolides2(x, y, model = "blm", start = c(1, 1),
optim.method = "DEoptim")
bolides2 <- function(x, y, model = "explore", equation = NULL, start,
optim.method = "Nelder-Mead", xmin = min(bound$x),
xmax = max(bound$x), plot = TRUE, bp_col = "red",
bp_pch = 16, bl_col = "red", lwd = 1,
line_smooth = 1000, lower = NULL, upper = NULL, ...) {
BLMod <- model
# Ensure DEoptim package is loaded if selected
if (optim.method == "DEoptim" && !requireNamespace("DEoptim", quietly = TRUE)) {
stop("The DEoptim package is required for this optimization method. Please install it.")
}
# Example for the two-parameter linear model
if (model == "blm") {
v <- length(start)
if (v > 2) stop("start has more than two values")
if (v < 2) stop("start has less than two values")
trap <- function(x, ar, br) {
yr <- ar + br * x
return(yr)
}
rss <- function(params, x, y) {
ar <- params[1]
br <- params[2]
yf <- unlist(lapply(x, FUN = trap, ar = ar, br = br))
err <- sum((y - yf)^2) / length(x)
return(err)
}
if (optim.method == "DEoptim") {
# Define bounds if not provided
if (is.null(lower)) lower <- c(-Inf, -Inf)
if (is.null(upper)) upper <- c(Inf, Inf)
# Run DEoptim
result <- DEoptim::DEoptim(rss, lower = lower, upper = upper,
DEoptim.control(trace = TRUE),
x = newdata5$x, y = newdata5$y)
# Extract optimized parameters
arf <- result$optim$bestmem[1]
brf <- result$optim$bestmem[2]
RMS <- result$optim$bestval
} else {
# Default to optim
ooo <- optim(start, rss, x = newdata5$x, y = newdata5$y, method = optim.method)
arf <- ooo$par[1]
brf <- ooo$par[2]
RMS <- ooo$value
}
if (plot == TRUE) {
xfine <- seq(min(x, na.rm = TRUE), max(x, na.rm = TRUE),
length.out = line_smooth)
yfit <- unlist(lapply(xfine, FUN = trap, ar = arf, br = brf))
lines(xfine, yfit, lwd = lwd, col = bl_col)
}
estimates <- matrix(c(arf, brf), nrow = 2, ncol = 1,
dimnames = list(c("\u03B2\u2081", "\u03B2\u2082"),
c("Estimate")))
Equation <- noquote("y = \u03B2\u2081 + \u03B2\u2082x")
Parameters <- list(Model = BLMod, Equation = Equation,
Parameters = estimates, RMS = RMS,
Boundary_points = newdata6)
class(Parameters) <- "wm" # Necessary for only printing part of the output
return(Parameters)
}
# Additional models and logic remain unchanged...
}
library(DEoptim)
# Example data
x <- 1:10
y <- 2 + 3 * x + rnorm(10)
# Call the function with DEoptim
result <- bolides2(x, y, model = "blm", start = c(1, 1),
optim.method = "DEoptim")
print(result)
bolides2 <- function(x, y, model = "explore", equation = NULL, start,
optim.method = "Nelder-Mead", xmin = min(bound$x),
xmax = max(bound$x), plot = TRUE, bp_col = "red",
bp_pch = 16, bl_col = "red", lwd = 1,
line_smooth = 1000, lower = NULL, upper = NULL, ...) {
BLMod <- model
# Ensure DEoptim package is loaded if selected
if (optim.method == "DEoptim" && !requireNamespace("DEoptim", quietly = TRUE)) {
stop("The DEoptim package is required for this optimization method. Please install it.")
}
y_max<-numeric()
dat<-data.frame(x=x,y=y)
test<-which(is.na(dat$x)==TRUE|is.na(dat$y)==TRUE)                # To Removes NA's
if(length(test)>0){
data<-dat[-which(is.na(dat$x)==TRUE|is.na(dat$y)==TRUE),]}else{ # To Removes NA's
data<-dat
}
#### Selecting maximum y values for each value of x ------------------------------------
data1<- data[order(data$x),]
for(i in unique(na.omit(data1$x))){
max(data1$y[which(data1$x==i)])->y_max[which(unique(na.omit(data1$x))==i)]
y_max
}
newdata<-data.frame(x=unique(na.omit(data1$x)),y_max)
## Removing points that have y value smaller than previous ----------------------------
bound<-newdata$y_max
for(i in 1:length(bound)){
bound[i]<-max(bound[i],max(newdata$y_max[1:i]))
}
newdata2<-data.frame(x=unique(na.omit(data1$x)),y=bound)
## Removing repeated values ------------------------------------------------------------
trim<-newdata2$y
dummy<-c(min(newdata2$y)*10,newdata2$y)
for(i in 1:length(newdata2$y)){
trim[i]<-newdata2$y[i]==dummy[i]
}
newdata2$trim<-trim
newdata2<-newdata2[-which(newdata2$trim==1),]
## Selection of points in descending order from xmax -----------------------------------
y_max2<-numeric()
data2<-data
data21<- data2[order(data2$x,decreasing = TRUE),]
for(i in unique(na.omit(data21$x))){
max(data21$y[which(data21$x==i)])->y_max2[which(unique(na.omit(data21$x))==i)]
y_max2
}
newdata3<-data.frame(x=unique(na.omit(data21$x)),y_max2)
## Removing points that have y value smaller than previous -----------------------------
bound2<-newdata3$y_max2
for(i in 1:length(bound2)){
bound2[i]<-max(bound2[i],max(newdata3$y_max2[1:i]))
}
newdata4<-data.frame(x=unique(na.omit(data21$x)),y=bound2)
## Removing repeated values -----------------------------------------------------------
trim2<-newdata4$y
dummy2<-c(min(newdata4$y)*10,newdata4$y)
for(i in 1:length(newdata4$y)){
trim2[i]<-newdata4$y[i]==dummy2[i]
}
newdata4$trim<-trim2
newdata4<-newdata4[-which(newdata4$trim==1),]
newdata6<-data.frame(x=c(newdata2$x,newdata4$x),y=c(newdata2$y,newdata4$y))
if(plot==TRUE){
plot(x,y,...)
points(newdata6$x,newdata6$y, col=bp_col, pch=bp_pch)
}
## Setting data limits for boundary model fitting --------------------------------------
bound<-newdata6
L<-xmin
U<-xmax
if(L<min(bound$x)) stop("The set minimum limit is less than the mimum of bounding points")
if(U>max(bound$x)) stop("The set maximum limit is greater than the maximum of bounding points")
ifelse(L==min(bound$x), bound2<-bound, bound2<-bound[-which(bound$x<L),])
ifelse(U==max(bound2$x), newdata5<-bound2, newdata5<-bound2[-which(bound2$x>U),])
## Exploring data points to choose model ----------------------------------------------
if(model=="explore"){
if(plot==TRUE){
plot(x,y,...)
points(newdata6$x,newdata6$y, col=bp_col, pch=bp_pch)}
return(summary(newdata6))
}
# Example for the two-parameter linear model
if (model == "blm") {
v <- length(start)
if (v > 2) stop("start has more than two values")
if (v < 2) stop("start has less than two values")
trap <- function(x, ar, br) {
yr <- ar + br * x
return(yr)
}
rss <- function(params, x, y) {
ar <- params[1]
br <- params[2]
yf <- unlist(lapply(x, FUN = trap, ar = ar, br = br))
err <- sum((y - yf)^2) / length(x)
return(err)
}
if (optim.method == "DEoptim") {
# Define bounds if not provided
if (is.null(lower)) lower <- c(-Inf, -Inf)
if (is.null(upper)) upper <- c(Inf, Inf)
# Run DEoptim
result <- DEoptim::DEoptim(rss, lower = lower, upper = upper,
DEoptim.control(trace = TRUE),
x = newdata5$x, y = newdata5$y)
# Extract optimized parameters
arf <- result$optim$bestmem[1]
brf <- result$optim$bestmem[2]
RMS <- result$optim$bestval
} else {
# Default to optim
ooo <- optim(start, rss, x = newdata5$x, y = newdata5$y, method = optim.method)
arf <- ooo$par[1]
brf <- ooo$par[2]
RMS <- ooo$value
}
if (plot == TRUE) {
xfine <- seq(min(x, na.rm = TRUE), max(x, na.rm = TRUE),
length.out = line_smooth)
yfit <- unlist(lapply(xfine, FUN = trap, ar = arf, br = brf))
lines(xfine, yfit, lwd = lwd, col = bl_col)
}
estimates <- matrix(c(arf, brf), nrow = 2, ncol = 1,
dimnames = list(c("\u03B2\u2081", "\u03B2\u2082"),
c("Estimate")))
Equation <- noquote("y = \u03B2\u2081 + \u03B2\u2082x")
Parameters <- list(Model = BLMod, Equation = Equation,
Parameters = estimates, RMS = RMS,
Boundary_points = newdata6)
class(Parameters) <- "wm" # Necessary for only printing part of the output
return(Parameters)
}
# Additional models and logic remain unchanged...
}
library(DEoptim)
# Example data
x <- 1:10
y <- 2 + 3 * x + rnorm(10)
# Call the function with DEoptim
result <- bolides2(x, y, model = "blm", start = c(1, 1),
optim.method = "DEoptim")
print(result)
# Call the function with DEoptim
result <- bolides2(x, y, model = "blm", start = c(1, 1),
optim.method = "Nelder-Mead")
library(BLA)
library(aplpack)
x<-soil$P
y<-soil$yield
# 1. Data exploration
summastat(x)
summastat(log(x))
x<-log(x) # transforms soil P to log
summastat(y)
# 2. Outlier detection
vals_ur<-data.frame(x,y)
bag<-bagplot(vals_ur, ylim=c(0,20), show.whiskers =F,create.plot = TRUE) # run the bagplot function
legend("topright", c("bag","loop","outliers", "d.median"),
pch = c(15,15,16,8),col=c("blue","lightblue","red","red"),
cex=0.7)
vals<-rbind(bag$pxy.bag,bag$pxy.outer) # to remove outliers, select points in the bag and loop only
# 3.Test for presence of boundary in dataset
x<-vals[,1]
y<-vals[,2]
start<-c(5,3,14,94,-19)
bolides2 <- function(x, y, model = "explore", equation = NULL, start,
optim.method = "Nelder-Mead", xmin = min(bound$x),
xmax = max(bound$x), plot = TRUE, bp_col = "red",
bp_pch = 16, bl_col = "red", lwd = 1,
line_smooth = 1000, lower = NULL, upper = NULL, ...) {
BLMod <- model
# Ensure DEoptim package is loaded if selected
if (optim.method == "DEoptim" && !requireNamespace("DEoptim", quietly = TRUE)) {
stop("The DEoptim package is required for this optimization method. Please install it.")
}
y_max<-numeric()
dat<-data.frame(x=x,y=y)
test<-which(is.na(dat$x)==TRUE|is.na(dat$y)==TRUE)                # To Removes NA's
if(length(test)>0){
data<-dat[-which(is.na(dat$x)==TRUE|is.na(dat$y)==TRUE),]}else{ # To Removes NA's
data<-dat
}
#### Selecting maximum y values for each value of x ------------------------------------
data1<- data[order(data$x),]
for(i in unique(na.omit(data1$x))){
max(data1$y[which(data1$x==i)])->y_max[which(unique(na.omit(data1$x))==i)]
y_max
}
newdata<-data.frame(x=unique(na.omit(data1$x)),y_max)
## Removing points that have y value smaller than previous ----------------------------
bound<-newdata$y_max
for(i in 1:length(bound)){
bound[i]<-max(bound[i],max(newdata$y_max[1:i]))
}
newdata2<-data.frame(x=unique(na.omit(data1$x)),y=bound)
## Removing repeated values ------------------------------------------------------------
trim<-newdata2$y
dummy<-c(min(newdata2$y)*10,newdata2$y)
for(i in 1:length(newdata2$y)){
trim[i]<-newdata2$y[i]==dummy[i]
}
newdata2$trim<-trim
newdata2<-newdata2[-which(newdata2$trim==1),]
## Selection of points in descending order from xmax -----------------------------------
y_max2<-numeric()
data2<-data
data21<- data2[order(data2$x,decreasing = TRUE),]
for(i in unique(na.omit(data21$x))){
max(data21$y[which(data21$x==i)])->y_max2[which(unique(na.omit(data21$x))==i)]
y_max2
}
newdata3<-data.frame(x=unique(na.omit(data21$x)),y_max2)
## Removing points that have y value smaller than previous -----------------------------
bound2<-newdata3$y_max2
for(i in 1:length(bound2)){
bound2[i]<-max(bound2[i],max(newdata3$y_max2[1:i]))
}
newdata4<-data.frame(x=unique(na.omit(data21$x)),y=bound2)
## Removing repeated values -----------------------------------------------------------
trim2<-newdata4$y
dummy2<-c(min(newdata4$y)*10,newdata4$y)
for(i in 1:length(newdata4$y)){
trim2[i]<-newdata4$y[i]==dummy2[i]
}
newdata4$trim<-trim2
newdata4<-newdata4[-which(newdata4$trim==1),]
newdata6<-data.frame(x=c(newdata2$x,newdata4$x),y=c(newdata2$y,newdata4$y))
if(plot==TRUE){
plot(x,y,...)
points(newdata6$x,newdata6$y, col=bp_col, pch=bp_pch)
}
## Setting data limits for boundary model fitting --------------------------------------
bound<-newdata6
L<-xmin
U<-xmax
if(L<min(bound$x)) stop("The set minimum limit is less than the mimum of bounding points")
if(U>max(bound$x)) stop("The set maximum limit is greater than the maximum of bounding points")
ifelse(L==min(bound$x), bound2<-bound, bound2<-bound[-which(bound$x<L),])
ifelse(U==max(bound2$x), newdata5<-bound2, newdata5<-bound2[-which(bound2$x>U),])
## Exploring data points to choose model ----------------------------------------------
if(model=="explore"){
if(plot==TRUE){
plot(x,y,...)
points(newdata6$x,newdata6$y, col=bp_col, pch=bp_pch)}
return(summary(newdata6))
}
# Example for the two-parameter linear model
if (model == "blm") {
v <- length(start)
if (v > 2) stop("start has more than two values")
if (v < 2) stop("start has less than two values")
trap <- function(x, ar, br) {
yr <- ar + br * x
return(yr)
}
rss <- function(params, x, y) {
ar <- params[1]
br <- params[2]
yf <- unlist(lapply(x, FUN = trap, ar = ar, br = br))
err <- sum((y - yf)^2) / length(x)
return(err)
}
if (optim.method == "DEoptim") {
# Define bounds if not provided
if (is.null(lower)) lower <- c(-Inf, -Inf)
if (is.null(upper)) upper <- c(Inf, Inf)
# Run DEoptim
result <- DEoptim::DEoptim(rss, lower = lower, upper = upper,
DEoptim.control(trace = TRUE),
x = newdata5$x, y = newdata5$y)
# Extract optimized parameters
arf <- result$optim$bestmem[1]
brf <- result$optim$bestmem[2]
RMS <- result$optim$bestval
} else {
# Default to optim
ooo <- optim(start, rss, x = newdata5$x, y = newdata5$y, method = optim.method)
arf <- ooo$par[1]
brf <- ooo$par[2]
RMS <- ooo$value
}
if (plot == TRUE) {
xfine <- seq(min(x, na.rm = TRUE), max(x, na.rm = TRUE),
length.out = line_smooth)
yfit <- unlist(lapply(xfine, FUN = trap, ar = arf, br = brf))
lines(xfine, yfit, lwd = lwd, col = bl_col)
}
estimates <- matrix(c(arf, brf), nrow = 2, ncol = 1,
dimnames = list(c("\u03B2\u2081", "\u03B2\u2082"),
c("Estimate")))
Equation <- noquote("y = \u03B2\u2081 + \u03B2\u2082x")
Parameters <- list(Model = BLMod, Equation = Equation,
Parameters = estimates, RMS = RMS,
Boundary_points = newdata6)
class(Parameters) <- "wm" # Necessary for only printing part of the output
return(Parameters)
}
if (model == "lp") {
Equation <- noquote("y = min(\u03B2\u2081 + \u03B2\u2082x, \u03B2\u2080)")
# Define the Linear Plateau function
trap1 <- function(x, ar, br, ym) {
yr <- ar + br * x
yout <- pmin(yr, ym) # Plateau at \u03B2\u2080 (ym)
return(yout)
}
# Loss function for the Linear Plateau model
rss1 <- function(start, x, y) {
ar <- start[1]
br <- start[2]
ym <- start[3]
yf <- unlist(lapply(x, FUN = trap1, ar = ar, br = br, ym = ym))
err <- sum((y - yf)^2) / length(x)
return(err)
}
# Scaling function for optimization
parscale1 <- function(a, x, y) {
eps <- 1e-4
nr <- length(a)
part <- vector("numeric", nr)
for (i in 1:nr) {
del <- rep(0, nr)
del[i] <- eps
part[i] <- (rss1((a + del), x, y) - rss1((a), x, y)) / eps
}
return(part)
}
# Optimization using `optim` or `DEoptim`
if (optim.method == "DEoptim") {
if (is.null(lower)) lower <- c(-Inf, -Inf, -Inf)
if (is.null(upper)) upper <- c(Inf, Inf, Inf)
result <- DEoptim::DEoptim(rss1, lower = lower, upper = upper,
DEoptim.control(trace = TRUE),
x = newdata5$x, y = newdata5$y)
arf <- result$optim$bestmem[1]
brf <- result$optim$bestmem[2]
ymf <- result$optim$bestmem[3]
RMS <- result$optim$bestval
} else {
ooo <- optim(start, rss1, x = newdata5$x, y = newdata5$y, method = optim.method)
scale <- 1 / abs(parscale1(ooo$par, x = newdata5$x, y = newdata5$y))
oo <- optim(ooo$par, rss1, x = newdata5$x, y = newdata5$y, method = optim.method,
control = list(parscale = scale))
ifelse(any(is.nan(oo$par)) == TRUE, oo <- ooo, oo <- oo)
arf <- oo$par[1]
brf <- oo$par[2]
ymf <- oo$par[3]
RMS <- oo$value
}
# Plot the fitted model
if (plot == TRUE) {
xfine <- seq(min(x, na.rm = TRUE), max(x, na.rm = TRUE), length.out = line_smooth)
yfit <- unlist(lapply(xfine, FUN = trap1, ar = arf, br = brf, ym = ymf))
lines(xfine, yfit, lwd = lwd, col = bl_col)
}
# Prepare the output
estimates <- matrix(c(arf, brf, ymf), nrow = 3, ncol = 1,
dimnames = list(c("\u03B2\u2081", "\u03B2\u2082", "\u03B2\u2080"),
c("Estimate")))
Parameters <- list(Model = BLMod, Equation = Equation, Parameters = estimates,
RMS = RMS, Boundary_points = newdata6)
class(Parameters) <- "wm" # Necessary for only printing part of the output
return(Parameters)
}
}
bolides2(x,y, start = start,model = "trapezium",
xlab=expression("Phosphorus/ln(mg L"^-1*")"),
ylab=expression("Yield/ t ha"^-1), pch=16,
col="grey", bp_col="grey", optim.method = "SANN")
bolides(x,y, start = start,model = "trapezium",
xlab=expression("Phosphorus/ln(mg L"^-1*")"),
ylab=expression("Yield/ t ha"^-1), pch=16,
col="grey", bp_col="grey", optim.method = "SANN")
bolides2(x,y, start = start,model = "trapezium",
xlab=expression("Phosphorus/ln(mg L"^-1*")"),
ylab=expression("Yield/ t ha"^-1), pch=16,
col="grey", bp_col="grey", optim.method = "SANN")
bolides2(x,y, start = start,model = "trapezium",
xlab=expression("Phosphorus/ln(mg L"^-1*")"),
ylab=expression("Yield/ t ha"^-1), pch=16,
col="grey", bp_col="grey")
n<-bolides2(x,y, start = start,model = "trapezium",
xlab=expression("Phosphorus/ln(mg L"^-1*")"),
ylab=expression("Yield/ t ha"^-1), pch=16,
col="grey", bp_col="grey")
n
